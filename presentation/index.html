<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>A simple scene</title>
    <link href="http://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Reenie+Beanie" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="highlight.min.css">
    <style>
    html {
        height: 100%;
        font-family: sans-serif;
    }
    h2 {
        font-size: 2.5em;
        font-weight: normal;
        font-style: italic;
    }
    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
        font-size: 1.3em;
        font-family: Roboto, sans-serif;
    }
    iframe , section {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border: 0;
        z-index: 0;
    }
    section {
        display: none;
    }
    ul {
        padding: 0;
        margin: 0;
    }
    ul li {
        list-style-type: none;
    }
    ul ol li {
        list-style-type: decimal;
    }
    .content {
        z-index: 1;
        position: absolute;
        top: 0;
        left: 0;
        background: #333;
        color: #fff;
        display: none;
    }
    .transitionable {
        transition: left 0.75s ease-in-out;
    }
    .subsection {
        padding: 12px;
        display: none;
    }
    .content .subsection:first-of-type {
        display: block;
    }
    .intro {
        background: #69f;
        font-family: 'Reenie Beanie', serif;
        height: 100%;
        text-align: center;
    }
    .intro h2 {
        position: relative;
        top: 50%;
        transform: translateY(-50%);
        color: #fff;
    }
    .intro h3 {
        position: relative;
        top: 50%;
        transform: translateY(-50%);
        color: #fff;
    }
    .always-invisible {
        visibility: hidden;
        padding: 0;
    }
    </style>
  </head>
  <body>

    <section class="intro">
        <h2>Learning Three.js</h2>
        <h3>Dan Neame <a href="https://twitter.com/cham">@cham</a></h3>
        <h3><a href="http://dan.nea.me">dan.nea.me</a></h3>
    </section>

    <section class="intro">
        <h2>What is Three.js?</h2>
    </section>
    <section>
        <iframe data-src="http://www.youtube.com/embed/ADRf8SE3RbM?autoplay=1&amp;autohide=1&amp;start=31" width="100%" height="100%" wmode="transparent"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Three.js is a JavaScript library that makes working with WebGL simpler</li>
                    <li>It gives you a higher abstraction over the raw WebGL code</li>
                    <li>This allows you to work with Spheres and Cubes instead of Vertices and Matrixes</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The abstraction means you can spend more time working on the visualisation or application you want to build</li>
                    <li>Rather than spending your time doing matrix transforms and calculating points on a mesh</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>It's an open source project, built and maintained by Ricardo Cabello, aka "Mr Doob"</li>
                    <li>You can find it on GitHub - https://github.com/mrdoob/three.js</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The minified source weighs in at about 400kb</li>
                    <li>The bower package pulls down the whole repo, which is hundreds of megabytes</li>
                    <li>Probably best to use the minified file rather than the bower package for now</li>
                    <li>It's not available as an AMD module yet, so you'll need to access it as window.THREE after imported</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Adding the library is straightforward:</li>
                </ul>
<pre><code class="html">
  &lt;body&gt;
    &lt;script src="three.min.js"&gt;&lt;/script&gt;
    &lt;script src="your-stuff.js"&gt;&lt;/script&gt;
  &lt;/body&gt;

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="http://pablotheflamingo.com/" width="100%" height="100%" wmode="transparent"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>WebGL doesn't have to be used for 3D</li>
                    <li>It's also great for 2D!</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>There are a bunch of advantages to rendering your graphics on the GPU rather than the CPU</li>
                    <li>If you render and animate on the CPU, your animation and rendering will be competing with everything else going on in your app</li>
                    <li>You get a single thread per browser window</li>
                    <li>You might even end up competing with everything else going on in the operating system!</li>
                    <li>This means you often have to reduce complexity in your visualisations and apps quite early on</li>
                    <li>It can also result in chop and stuttering</li>
                    <li>This is even why CSS, for example, is moving towards hardware accellerated animation</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>If you're lucky, you'll have 4 or 8 cores available on your CPU</li>
                    <li>Modern GPUs have about 1500 cuda cores</li>
                    <li>GPU cores are <i>great</i> at executing a huge number of parallel computations</li>
                    <li>The hardware is specifically designed for rendering and animating graphics</li>
                    <li>(Or you can use them to mine Dogecoins)</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../intro-examples/physijs.html" width="100%" height="100%" wmode="transparent"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Three.js has a number of plugins available</li>
                    <li>For example, Physi.js is a physics engine you can plug in to magically enable physics in your scenes</li>
                    <li>There are also a bunch of custom shaders available, Post Processing effects, and so on</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="http://www.youtube.com/embed/GF2s5r-trRQ?autoplay=1&amp;autohide=1" width="100%" height="100%" wmode="transparent"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>You can also use Three.js to build Games, Simulations, Virtual Worlds, etc etc</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Three.js has been around for about 5 years now</li>
                    <li>The docs used to be truly awful but have come along a lot recently</li>
                    <li>Still, a lot of people learn by looking at examples and reverse engineering them</li>
                    <li>In this talk I'll try to give you a decent introduction so you can skip the first few weeks of figuring out how it works!</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
    </section>

    <section class="intro">
        <h2>A simple scene</h2>
    </section>
    <section>
        <iframe data-src="../lights-camera-objects/a-simple-scene.html" width="100%" height="100%" wmode="transparent"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Scenes are containers for your three.js objects</li>
                    <li>You <i>can</i> have multiple scenes, but usually you only need one</li>
                </ul>
<pre><code class="js">
    var scene = new THREE.Scene(); // fill me with stuff!

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>We'll need a camera to take pictures of our scene</li>
                    <li>As with scenes, you'll often only need one of these</li>
                    <li>There are a few different types of camera, but PerspectiveCamera will give you a 'natural' look</li>
                    <li>It takes 4 arguments - the field of view, the view aspect, the 'near' cutoff and the 'far' cutoff</li>
                    <li>If you don't need to specify an argument, leave it out to use the default value</li>
                </ul>
<pre><code class="js">
    var wSize = windowSize();
    var camera = new THREE.PerspectiveCamera(40, wSize.width / wSize.height);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>The renderer renders the objects in our scene to the screen</li>
                    <li>There are 3 renderers - CSS, Canvas and WebGL</li>
                    <li>We'll only deal with the WebGL renderer for this talk</li>
                </ul>
<pre><code class="js">
    var renderer = new THREE.WebGLRenderer();

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Now that we have our scene, camera and renderer, we set the size of the renderer...</li>
                    <li>Execute a render, specifying the scene we want to render and the camera to render with...</li>
                    <li>and append the domElement of the renderer to the body of our HTML document</li>
                </ul>
<pre><code class="js">
    renderer.setSize(wSize.width, wSize.height);
    renderer.render(scene, camera);

    document.body.appendChild(renderer.domElement);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>The exciting result is an empty screen, as we've not added anything to our scene yet!</li>
                    <li>You can change the background colour of our render via renderer.setClearColor(hex);</li>
                </ul>
<pre><code class="js">
    renderer.setClearColor(0xff6699);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the code in it's entirety, it's running in the background right now</li>
                </ul>
<pre><code class="js">
    function windowSize(){
        return {
            width: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
            height: Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
        };
    }

    var wSize = windowSize();

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(40, wSize.width / wSize.height);
    var renderer = new THREE.WebGLRenderer();

    renderer.setClearColor(0xff6699);
    renderer.setSize(wSize.width, wSize.height);
    renderer.render(scene, camera);

    document.body.appendChild(renderer.domElement);

</code></pre>
        </div>
    </section>

    <section class="intro">
        <h2>A less simple scene</h2>
    </section>
    <section>
        <iframe data-src="../lights-camera-objects/a-less-simple-scene.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Our scene works but is a bit boring, there's nothing in it!</li>
                    <li>let's add a sphere to start</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Meshes in Three are composed of two things - Geometry and one or more Materials</li>
                    <li>Think of geometry as the shape and material as the paint</li>
                    <li>When these are combined, we have a Mesh that can be added to the scene</li>
                </ul>
<pre><code class="js">
    var mesh = new THREE.Mesh(geometry, material);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Spheres take 7 arguments, for a basic sphere you only need the first argument - the radius</li>
                    <li>The next two arguments define the number of horizontal and vertical segments</li>
                    <li><small>(the next four are used to make sphere segments, if you just want a part of a sphere)</small></li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.SphereGeometry(50, 16, 16);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>After we have defined our Geometry, it's time to paint it with a Material</li>
                    <li>MeshBasicMaterial defines a basic material</li>
                    <li>This material type does not require lighting, and simply paints it the colour we've specified</li>
                    <li>Materials take a bunch of options - I'm not going to cover them all, the docs are pretty comprehensive</li>
                </ul>
<pre><code class="js">
    var material = new THREE.MeshBasicMaterial({color: 0x00ff00});

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's our complete sphere() function</li>
                </ul>
<pre><code class="js">
    function sphere(){
        var geometry = new THREE.SphereGeometry(50, 16, 16);
        var material = new THREE.MeshBasicMaterial({color: 0x00ff00});

        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>To add it to the scene, we use scene.add</li>
                </ul>
<pre><code class="js">
    scene.add(sphere());

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>And we'll need to move the camera out a bit, so it's not inside the sphere</li>
                </ul>
<pre><code class="js">
    camera.position.set(0, 0, 300);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>It looks like a circle since the basic material does not show any shading</li>
                    <li>If we turn on wireframes then it's a bit clearer what's going on</li>
                    <li><small>Some live coding here! Or edit a-less-simple-scene.html to the following:</small></li>
                </ul>
<pre><code class="js">
    function sphere(){
        var geometry = new THREE.SphereGeometry(50, 16, 16);
        var material = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true
        });

        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the code for our less simple scene</b></li>
                </ul>
<pre><code class="js">
    function sphere(){
        var geometry = new THREE.SphereGeometry(50, 16, 16);
        var material = new THREE.MeshBasicMaterial({color: 0x00ff00});

        return new THREE.Mesh(geometry, material);
    }

    var wSize = windowSize();

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(40, wSize.width / wSize.height);
    var renderer = new THREE.WebGLRenderer();

    scene.add(sphere());

    camera.position.set(0, 0, 300);

    renderer.setClearColor(0xffffff);
    renderer.setSize(wSize.width, wSize.height);
    renderer.render(scene, camera);

    document.body.appendChild(renderer.domElement);

</code></pre>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>A lit scene</h2>
    </section>
    <section>
        <iframe data-src="../lights-camera-objects/a-lit-scene.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>If we want anything other than basic materials then we're going to need some lights</li>
                    <li>There are a bunch of different lights in Three that all work in different ways</li>
                    <li>In this example we'll use a SpotLight</li>
                </ul>
<pre><code class="js">
    var light = new THREE.SpotLight();

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Spotlights have a <b>position</b> and shine a cone of light on a <b>target</b></li>
                    <li>The target will be 0, 0, 0 by default, but I've included it for reference</li>
                </ul>
<pre><code class="js">
    light.position.set(1000, 1000, 1000);
    light.target.set(0, 0, 0);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>SpotLights take up to 5 arguments:</b></li>
                    <li>Their colour</li>
                    <li>Their intensity</li>
                    <li>The distance they illuminate to (default 0 = infinity)</li>
                    <li>The angle of the light cone</li>
                    <li>The falloff rate, if distance is not 0</li>
                </ul>
<pre><code class="js">
    var light = new THREE.SpotLight(0xff0000, 0.8, 500, 90, 2);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>I've changed the material the sphere uses to a Lambert material, so that the light affects it</li>
                    <li>I'll cover materials in more detail later</b></li>
                </ul>
<pre><code class="js">
    function sphere(){
        var geometry = new THREE.SphereGeometry(50, 16, 16);
        var material = new THREE.MeshLambertMaterial({color: 0x00ff00});

        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the code for our lit scene</b></li>
                </ul>
<pre><code class="js">
    function sphere(){
        var geometry = new THREE.SphereGeometry(50, 16, 16);
        var material = new THREE.MeshLambertMaterial({color: 0x00ff00});

        return new THREE.Mesh(geometry, material);
    }

    var wSize = windowSize();

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(40, wSize.width / wSize.height);
    var renderer = new THREE.WebGLRenderer();
    var light = new THREE.SpotLight();

    scene.add(sphere());
    scene.add(light);

    camera.position.set(0, 0, 300);
    light.position.set(1000, 1000, 1000);

    renderer.setClearColor(0xffffff);
    renderer.setSize(wSize.width, wSize.height);
    renderer.render(scene, camera);

    document.body.appendChild(renderer.domElement);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Object Positions</h2>
    </section>
    <section>
        <iframe data-src="../lights-camera-objects/multiple-spheres.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>It's straightforward to add multiple spheres to our scene</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>I've added a new function called "randomlyPositionedSphere"</li>
                    <li>This function calls sphere() as with our last example, but also sets the position of our sphere</li>
                    <li>The position is random within the range specified with maxPosition, in all three axes</li>
                </ul>
<pre><code class="js">
    function randomlyPositionedSphere(maxPosition){
        var mesh = sphere();

        mesh.position.set(
            (Math.random() * maxPosition) - (maxPosition / 2),
            (Math.random() * maxPosition) - (maxPosition / 2),
            (Math.random() * maxPosition) - (maxPosition / 2)
        );

        return mesh;
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Then we call randomlyPositionedSphere 100 times with a for loop</li>
                </ul>
<pre><code class="js">
    for(var i = 0; i < 100; i++){
        scene.add(randomlyPositionedSphere(boxSize));
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Refreshing the page gives us a random scene each time</li>
                </ul>
            </div>
        </div>
    </section>

    <section class="intro">
        <h2>Animation</h2>
    </section>
    <section>
        <iframe data-src="../animation-basics/circular-motion.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Time for some maths!</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>To plot the path of a circle, we can use a sine and cosine wave:</li>
                    <li>A sine wave for one axis, and a cosine wave for the other</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
            <div class="subsection">
                <ul>
                    <li>If both axes use a sine wave, or both use a cosine wave, then we get a nicely eased but linear line, diagonally</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../animation-basics/moving-camera.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Let's look at how we can use this to give our camera a circular path</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Up to now, we've only rendered the scene once</li>
                    <li>If we're going to have animation in the scene, we'll need to render each time something changes</li>
                    <li>requestAnimationFrame will allow us to render our scene up to 60 times per second</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>We create a tick function, that:</li>
                    <li>
                        <ol>
                            <li>positions the camera</li>
                            <li>renders the scene</li>
                            <li>increments a tick counter</li>
                            <li>schedules another call to itself with requestAnimationFrame</li>
                        </ol>
                    </li>
                </ul>
<pre><code class="js">
    function tick(){
        camera.position.set(cameraX, 0, cameraZ);

        renderer.render(scene, camera);

        tickCount += 0.01;
        requestAnimationFrame(tick);
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>In order to move the camera in a circular orbit, we set the x coordinate to a position on a sine wave, and the z coordinate to a position on a cosine wave</li>
                    <li>renderer.render(scene, camera) is replaced with the following code:</li>
                </ul>
<pre><code class="js">
    var tickCount = 0;
    function tick(){
        var cameraX = boxSize * Math.cos(tickCount);
        var cameraZ = boxSize * Math.sin(tickCount);

        camera.position.set(cameraX, 0, cameraZ);
        camera.lookAt(new THREE.Vector3(0,0,0));

        renderer.render(scene, camera);

        tickCount += 0.01;
        requestAnimationFrame(tick);
    }
    tick();

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>It's necessary to tell the camera where to look after we've moved it</li>
                    <li>Without camera.lookAt, it will keep facing in the same direction when moved rather than tracking 0, 0, 0</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../animation-basics/more-complicated-paths.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>A bit more maths!</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>This is the same example as before, but I've increased the period of the x co-ordinate</li>
                    <li>x is now Math.cos(time*3) instead of Math.cos(time)</li>
                    <li>This means that we'll be drawing 3 circles per iteration in x, and 1 in y</li>
                    <li>The result of this is a helix type path</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../animation-basics/moving-camera-2.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Here's the same path applied to the camera position in our sphere scene</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The only change is the following line in tick():</li>
                </ul>
<pre><code class="js">
        var cameraX = boxSize * Math.cos(tickCount*3);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>You can come up with some really interesting paths just by modifying the period of the sine and cosine waves</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../animation-basics/moving-camera-moving-objects.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Why not have each sphere follow a sine wave?</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>sphere() now gives the geometry a random size to make things a bit more interesting</li>
                </ul>
<pre><code class="js">
   function sphere(){
        var geometry = new THREE.SphereGeometry(Math.random() * 50, 16, 16);
        var material = new THREE.MeshLambertMaterial({color: 0x00ff00});

        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>randomlyPositionedSphere assigns a random "speed" Vector to each mesh</li>
                    <li>Vector3 is a simple object that represents a three dimensional Vector</li>
                    <li>You can use them for anything, but representing x, y and z is the most common case</li>
                </ul>
<pre><code class="js">
    function randomlyPositionedSphere(maxPosition){
        var mesh = sphere();

        mesh.position.set(
            (Math.random() * maxPosition) - (maxPosition / 2),
            (Math.random() * maxPosition) - (maxPosition / 2),
            (Math.random() * maxPosition) - (maxPosition / 2)
        );

        mesh.speed = new THREE.Vector3(
            Math.random() * 10 - 5,
            Math.random() * 10 - 5,
            Math.random() * 10 - 5
        );


        return mesh;
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>And on each tick(), we call moveSphere for each sphere in the scene:</li>
                </ul>
<pre><code class="js">
    function moveSphere(mesh, count){
        mesh.position.x += Math.sin(count) * mesh.speed.x;
        mesh.position.y += Math.sin(count) * mesh.speed.y;
        mesh.position.z += Math.sin(count) * mesh.speed.z;
    }

    ...

    function tick(){
        for(var i = 0; i < 100; i++){
            moveSphere(spheres[i], tickCount);
        }
        ...
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Reusing boilerplate code</h2>
    </section>
    <section>
        <iframe data-src="../animation-basics/moving-camera.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>There's a bit of repetition going on in our scenes now</li>
                    <li>We're always defining a scene, a camera, and a renderer</li>
                    <li>It makes sense to move this code to a separate file</li>
                    <li>This will allow us to concentrate on just the unique parts of our scenes rather than copy pasting boilerplate</li>
                    <li>It also keeps your files nice and light</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the code we should move to a separate file. We'll call it 'sandbox.js'</li>
                    <li>In later examples, we'll just include this file to set up the basic components of a scene for us</li>
                    <li>It's not <i>super</i> sophisticated, but it'll do for now - it just sets up a scene, camera and renderer and moves the camera round in a circle</li>
                </ul>
<pre><code class="js">
    function windowSize(){
        return {
            width: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
            height: Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
        };
    }

    var wSize = windowSize();

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(40, wSize.width / wSize.height);
    var renderer = new THREE.WebGLRenderer();

    renderer.setClearColor(0xffffff);
    renderer.setSize(wSize.width, wSize.height);

    camera.position.set(0, 50, 0);
    document.body.appendChild(renderer.domElement);

    var tickCount = 0;
    function tick(){
        requestAnimationFrame(tick);

        camera.position.x = Math.sin(tickCount) * 100;
        camera.position.z = Math.cos(tickCount) * 100;
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        renderer.render(scene, camera);

        tickCount += 0.005;
    }
    tick();

</code></pre>
            </div>
        </div>
    </section>

    <section class="intro">
        <h2>Geometries</h2>
    </section>
    <section>
        <iframe data-src="../objects/planes.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Planes</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Planes are one of the simplest geometries</li>
                    <li>Composed of four vertices and two faces</li>
                    <li>They have a width and height but no depth</li>
                    <li>Flat objects like this are known as 'Shapes'</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Their constructor takes width as the first argument and height as the second</li>
                    <li>The third and fourth (optional) arguments define how many width and height segments they should have respectively</li>
                </ul>
<pre><code class="js">
        var geometry = new THREE.PlaneGeometry(40, 60);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/vertices.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Vertices</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>A vertex is a point in 3d space</li>
                    <li>Geometries are composed of multiple vertices</li>
                    <li>The wireframe of an object is defined by the edges between these vertices</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Our plane has 4 vertices, which are highlighted in the example like so:</li>
                </ul>
<pre><code class="js">
    var object = plane();

    object.geometry.vertices.forEach(function(vertex){
        scene.add(positionedSphere(vertex.x, vertex.y, vertex.z));
    });

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/faces.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Faces</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>A face is an individual surface of a solid object</li>
                    <li>Faces are always flat, and usually triangles (THREE.Face3), though you can create custom geometry with square faces (THREE.Face4)</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Faces are defined by the vertices that they join together</li>
                    <li>In our face() function, we:
                        <ol>
                            <li>create a new Geometry and a basic blue Material</li>
                            <li>set the vertices of the Geometry to those passed to the function</li>
                            <li>define a single face composed of the 0th, 1st and 2nd vertex</li>
                            <li>return the Mesh</li>
                        </ol>
                    </li>
                    <li>This gives us the single blue face we see in the example</li>
                </ul>
<pre><code class="js">
    function face(vertices){
      var geometry = new THREE.Geometry();
      var material = new THREE.MeshBasicMaterial({ color: 0x0000ff });

      geometry.vertices = vertices;
      geometry.faces.push(new THREE.Face3(0, 1, 2));

      return new THREE.Mesh(geometry, material);
    }

    var object = plane();

    scene.add(
        face(object.geometry.vertices.slice(0, 3))
    );

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/boxes.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Normals</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/boxes.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Boxes (formerly "Cubes")</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Boxes have a similar constructor to planes, but with an extra dimension for depth</li>
                    <li>As with planes, you can supply an additional arguments if you want more segments in each dimension</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.BoxGeometry(40, 50, 60);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/circles.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Circles</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Circles are circular Shapes, made out of multiple Face3s</li>
                    <li>The default number of segments is 8, but you'll probably want to up this in nearly all instances</li>
                    <li>The example here is using 16 segments instead, so it has 17 vertices and 16 faces</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The first argument passed to CircleGeometry is the radius</li>
                    <li>The second argument passed to CircleGeometry is the segment count</li>
                    <li>The third and fourth arguments (both optional) allow you to define circle sections</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.CircleGeometry(40, 16);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/spheres.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Spheres</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Spheres are three dimensional circular geometries</li>
                    <li>Each vertex is at the same distance from the center point</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Spheres in Three.js are UV Spheres</li>
                    <li>This means they are generated with a sequence of rings and segments, like a plane wrapped around a central point</li>
                    <li>You can also make Spheres using icosa-, tetra-, octa- and dodeca-hedrons</li>
                    <li>UV Spheres are easiest to map textures onto due to their correlation with planes</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>As we covered earlier, SphereGeometries take 7 arguments</li>
                    <li>For a basic sphere you only need the first argument - the radius</li>
                    <li>The next two arguments define the number of horizontal and vertical segments</li>
                    <li>The next four are used to make partial spheres</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.SphereGeometry(40, 16, 12);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/rings.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Rings</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Rings are shapes defined by two circles</li>
                    <li>An outer circle, and an inner circle that defines a hole in the middle</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The RingGeometry constructor takes 6 arguments</li>
                    <li>The first two are the radii of the outer and inner circle</li>
                    <li>The third and fourth define the number of segments</li>
                    <li>The fifth and six allow you to define partial rings</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.RingGeometry(30, 24, 16, 2);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/tori.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Tori</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Spheres are to circles as tori are to rings</li>
                    <li>Instead of defining an outer and inner radius, you define the radius of the torus, and the radius of the tube</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The TorusGeometry constructor takes 5 arguments</li>
                    <li>Interestingly, this is one less than the RingGeometry</li>
                    <li>The first argument is the radius of the torus</li>
                    <li>The second argument is the radius of the tube</li>
                    <li>The third defines the number of radial segments</li>
                    <li>The fourth defines the number of tubular segments</li>
                    <li>The fifth argument allows you to draw partial tori</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.TorusGeometry(30, 6, 8, 16);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/torusknots.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Torus Knots</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Torus Knots are pretty fun geometries that generate some interesting shapes</li>
                    <li>They are defined in a similar way to tori, in that they have a radius and a tubular radius</li>
                    <li>The twisting shape is defined by two numbers, p and q</li>
                    <li>For a torus knot to be complete, both p and q must be integers</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The constructor of a TorusKnotGeometry takes 7 arguments</li>
                    <li>
                        <ol>
                            <li>The radius</li>
                            <li>The tubular radius</li>
                            <li>The number of radial segments</li>
                            <li>The number of tubular segments</li>
                            <li>p</li>
                            <li>q</li>
                            <li>The height scale - how much the torusknot deviates in the z axis</li>
                        </ol>
                    </li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.TorusKnotGeometry(30, 6, 64, 16);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/cylinders.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Cylinders</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Cylinders are circles extruded in the y axis</li>
                    <li>You can supply a different radius to the top and bottom of the cylinder</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>CylinderGeometry takes 6 arguments:</li>
                    <li>
                        <ol>
                            <li>The radius at the top of the cylinder</li>
                            <li>The radius at the bottom of the cylinder</li>
                            <li>The height of the cylinder</li>
                            <li>The number of radial segments</li>
                            <li>The number of height segments</li>
                            <li>A boolean denoting whether or not the cylinder is open (true) or capped (false)</li>
                        </ol>
                    </li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.CylinderGeometry(20, 20, 60);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/cones.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Cones</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>If you define one of the radii for a Cylinder as 0 then the result is a cone</li>
                    <li>Here's the same Cylinder we saw in the previous example, with a top radius of 0:</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.CylinderGeometry(0, 20, 60);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/pyramids.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Pyramids</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>A cone with three sides is a pyramid</li>
                    <li>Here's the same Cylinder we saw in the previous example, but with 3 radial segments:</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.CylinderGeometry(0, 20, 60, 3);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/all-hedrons.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Tetra-, icosa-, octa- and dodecahedrons</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>All define die-like shapes</li>
                    <li>As you increase the number of segments they become more like spheres</li>
                    <li>Better than UV Spheres if you need to alter their geometries</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>All of these geometries take 2 arguments:</li>
                    <li>
                        <ol>
                            <li>The radius of the geometry</li>
                            <li>The detail of the geometry (default 0)</li>
                        </ol>
                    </li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.TetrahedronGeometry(16);
    var geometry = new THREE.IcosahedronGeometry(16);
    var geometry = new THREE.OctahedronGeometry(16);
    var geometry = new THREE.DodecahedronGeometry(16);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/detailed-hedrons.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Detailed tetra-, icosa-, octa- and dodecahedrons</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here are some examples with their subdivisions turned up to 2:</li>
                    <li>Even with the smallest increase in vertices they begin to appear more like spheres</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.TetrahedronGeometry(16, 2);
    var geometry = new THREE.IcosahedronGeometry(16, 2);
    var geometry = new THREE.OctahedronGeometry(16, 2);
    var geometry = new THREE.DodecahedronGeometry(16, 2);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Materials</h2>
    </section>
    <section>
        <iframe data-src="../materials/sphere-lambert-basic-phong.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Material types</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>
                        The three most commonly used material types are:
                        <ol>
                            <li>Basic</li>
                            <li>Lambert</li>
                            <li>Phong</li>
                        </ol>
                    </li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li><b>MeshBasicMaterial</b></li>
                    <li>&nbsp;</li>
                    <li>The green sphere in this demo uses a MeshBasicMaterial</li>
                    <li>Basic materials are just that: pretty basic</li>
                    <li>They're good for scenes that don't require lighting, or where you need a uniform, flat colour</li>
                    <li>They can be great for visualisations where you want a flat style, or where you want an exact colour</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>MeshBasicMaterials usually have a colour</li>
                    <li>They can also have a texture, light, specular, alpha or environment map (more on these later)</li>
                    <li>Or you can show them as wireframes - like in the previous section on objects</li>
                    <li>In this example we've just given our sphere a flat green colour:</li>
                </ul>
<pre><code class="js">
    function basicSphere(){
        var geometry = new THREE.SphereGeometry(15, 64, 64);
        var material = new THREE.MeshBasicMaterial({color: 0x33ff66});

        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
            <div class="subsection">
                <ul>
                    <li><b>MeshLambertMaterial</b></li>
                    <li>&nbsp;</li>
                    <li>The brown sphere in this demo uses a MeshLambertMaterial</li>
                    <li>Unlike Basic materials, Lambert shaded materials take lighting into effect</li>
                    <li>They are good for creating dull, non-shiny objects like clay</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>MeshLambertMaterials take all the same parameters as MeshBasicMaterials</li>
                    <li>But since they are effected by lighting, they give a more realistic effect</li>
                </ul>
<pre><code class="js">
    function lambertSphere(){
        var geometry = new THREE.SphereGeometry(15, 64, 64);
        var material = new THREE.MeshLambertMaterial({color: 0xff6633});

        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
            <div class="subsection">
                <ul>
                    <li><b>MeshPhongMaterial</b></li>
                    <li>&nbsp;</li>
                    <li>The blue sphere in this demo uses a MeshPhongMaterial</li>
                    <li>These are very similar to Lambert materials, but have a shinier shading</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>MeshPhongMaterials, like Lambert, take all the same parameters as MeshBasicMaterials</li>
                    <li>They also have a 'shininess' parameter, which I've increased in this example (the default is 50)</li>
                </ul>
<pre><code class="js">
    function phongSphere(){
        var geometry = new THREE.SphereGeometry(15, 64, 64);
        var material = new THREE.MeshPhongMaterial({
            color: 0x3366ff,
            shininess: 90
        });
        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-shading.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Shading types</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>You can control the shading type for any material affected by lighting</li>
                    <li>This affects how the lighting is smoothed over each face</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>
                        In this example we have 3 Icosahedrons with the 3 different shading types:
                        <ol>
                            <li>Smooth shading, in blue (the default shading)</li>
                            <li>Flat shading, in green</li>
                            <li>No shading, in red</li>
                        </ol>
                    </li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Flat shading is much faster than smooth shading<li>
                    <li>As you can see, there's pretty much no discernable difference between Flat and No shading</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Phong shaded sphere</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Colouring in a sphere is pretty cool, but there's a lot more we can do with materials</li>
                    <li>You can make some pretty spectacular scenes with a simple object or two and good use of materials</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Let's make a realistic looking globe with just a few spheres</li>
                    <li>First off, we'll take a sphere and colour it blue</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>I've turned the shininess down on this sphere</li>
                    <li>This makes it look a bit more like a "sea" than the previous Phong sphere</li>
                </ul>
<pre><code class="js">
    function sphere(){
        var geometry = new THREE.SphereGeometry(40, 64, 64);
        var material = new THREE.MeshPhongMaterial({
            color: 0x3366ff,
            shininess: 50
        });

        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-texturemap.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Texture maps</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Texture maps are <i>great</i> for bringing a bit of life to your objects</li>
                    <li>They wrap a bitmap around your object</li>
                    <li>This is straightforward for UV spheres - SphereGeometries use this mapping</li>
                    <li>For an Icosahedron, you'd need a different map, based on triangles rather than a rectangle</li>
                    <li>For this reason, when you're working with textures and spheres, a SphereGeometry is usually easiest</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>In this example, we have the blue, phong-shaded sphere from our previous example on the right</li>
                    <li>And the same sphere with our texture map applied on the left</li>
                    <li>I've included a Plane in the background with the same texture applied to it</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The earth map is straight from Google images</li>
                    <li>This is what makes UV spheres so much easier to work with than Icosahedrons</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>If you want to distort the shape of your sphere, Icosahedrons are better</li>
                    <li>UV Spheres lead to 'tearing' since not all of their vertices are joined by a face</li>
                    <li>In Icosahedrons, no vertices form an edge, which you get at the top or bottom of UV spheres</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the code for our textured sphere</li>
                    <li>THREE.ImageUtils.loadTexture handles the loading of the texture for us, so it's pretty straightforward</li>
                    <li>Notice I've dropped the colour - it's not needed any more</li>
                </ul>
<pre><code class="js">
    function texturedSphere(){
        var textureMap = 'textures/earthmap.jpg';
        var geometry = new THREE.SphereGeometry(30, 64, 64);
        var material = new THREE.MeshPhongMaterial({
            map: THREE.ImageUtils.loadTexture(textureMap),
            shininess: 50
        });
        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-bumpmap.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Bump maps</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Bump maps are greyscale bitmaps, which can be used to simulate bumps and wrinkles on an object</li>
                    <li>They work by altering the surface of the object during lighting calculations</li>
                    <li>The <i>geometry</i> of the object is not changed - this is done by the shader</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>In this example, I've applied the same bump map to the blue sphere and to the textured sphere</li>
                    <li>You should be able to see the bumps on each</li>
                    <li>The bump map is shown behind, as a texture on the plane - the lighter the pixel, the higher the bump</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the texture and bump map applied to our sphere</li>
                    <li>Notice the bumpScale property - increasing this will increase the bump size on the sphere</li>
                </ul>
<pre><code class="js">
    function bumpSphere(){
        var textureMap = 'textures/earthmap.jpg';
        var bumpMap = 'textures/bumpmap.jpg';
        var geometry = new THREE.SphereGeometry(30, 64, 64);
        var material = new THREE.MeshPhongMaterial({
            map: THREE.ImageUtils.loadTexture(textureMap),
            shininess: 50,
            bumpMap: THREE.ImageUtils.loadTexture(bumpMap),
            bumpScale: 0.3
        });
        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-specularmap.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Specular maps</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Specular maps control how shiny each part of the object should be</li>
                    <li>Like bump maps, these are just greyscale bitmaps</li>
                    <li>The whiter the pixel, the shinier that part of the object will be</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>I've applied the specular map to our blue sphere and added it to our textured, bumped sphere</li>
                    <li>As before, it's viewable as a texture on the plane</li>
                    <li>This allows us to make only the sea shiny - the land isn't shiny at all</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the texture, bump and specular map applied to our sphere</li>
                </ul>
<pre><code class="js">
    function specularSphere(){
        var textureMap = 'textures/earthmap.jpg';
        var bumpMap = 'textures/bumpmap.jpg';
        var specularMap = 'textures/specularmap.jpg';
        var geometry = new THREE.SphereGeometry(30, 64, 64);
        var material = new THREE.MeshPhongMaterial({
            map: THREE.ImageUtils.loadTexture(textureMap),
            bumpMap: THREE.ImageUtils.loadTexture(bumpMap),
            bumpScale: 0.3,
            specularMap: THREE.ImageUtils.loadTexture(specularMap),
            shininess: 50
        });
        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-alphamap.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Alpha maps</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>So far we've done everything with just one sphere and one material</li>
                    <li>If we want to add clouds to our globe, they'll need to be on a separate sphere</li>
                    <li>What I've added here is an extra sphere, very slightly larger than our globe sphere, which rotates at a different speed</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The new, larger sphere has an alpha map applied</li>
                    <li>As you may have guessed, an alpha map controls the transparency of a material</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>You can also see the alpha map applied to a lone sphere by itself, next to our globe</li>
                    <li>Since clouds are white, we don't need to specify anything other than the alpha map</li>
                    <li>Where the alpha map is white, the object will be visible, and show it's default colour, which handily is white</li>
                    <li>We could quite easily make the clouds red by applying a colour property to our cloud sphere</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the code for our cloud sphere, whose radius is 0.1 units bigger than our globe sphere</li>
                    <li>The 'transparent' property is required in order to enable the alpha map</li>
                    <li>Notice the tick() method in our clouds function - this keeps the clouds spinning</li>
                </ul>
<pre><code class="js">
    function clouds(){
        var textureMap = 'textures/cloudmap.jpg';
        var geometry = new THREE.SphereGeometry(30.1, 64, 64);
        var material = new THREE.MeshPhongMaterial({
            alphaMap: THREE.ImageUtils.loadTexture(textureMap),
            transparent: true
        });
        var mesh = new THREE.Mesh(geometry, material);

        function tick(){
            requestAnimationFrame(tick);
            mesh.rotation.y += 0.0005;
        }
        tick();

        return mesh;
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-transparency.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Transparency</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Our cloud sphere in the previous example is a bit overpowering</li>
                    <li>We could knock the colour back a bit but then we'll get grey clouds</li>
                    <li>Ideally, the clouds should be partially transparent</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>This is pretty easy to achieve with the opacity property:</li>
                </ul>
<pre><code class="js">
    var material = new THREE.MeshPhongMaterial({
        alphaMap: THREE.ImageUtils.loadTexture(textureMap),
        transparent: true,
        opacity: 0.7
    });

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-materialsides.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Material sides</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>By default, materials will only show on the front / outside of the object's mesh</li>
                    <li>This is defined with THREE.FrontSide, or simply '0'</li>
                    <li>To have the material show on the back or 'inside' an object, set the side property to THREE.BackSide</li>
                    <li>Or if you want it on both the front and back, use THREE.DoubleSide</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>In this example, I've made a much bigger sphere, so that the camera is inside it</li>
                    <li>Then I've set the material to be a 'stars' map, only showing on the inside of the sphere</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The code is almost identical to the texture map example from earlier:</li>
                </ul>
<pre><code class="js">
    function stars(){
        var textureMap = 'textures/starmap.png';
        var geometry = new THREE.SphereGeometry(1000, 64, 64);
        var material = new THREE.MeshBasicMaterial({
            map: THREE.ImageUtils.loadTexture(textureMap),
            side: THREE.BackSide
        });

        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-customshader.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Custom shaders</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>For the glow around our earth we're going to need to make a custom shader</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Shaders are written in C</li>
                    <li>Can be a little tricky to get your head around</li>
                    <li>Fortunately, since they are "cross library", it's pretty easy to find them on the internet</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>
                        There are two main components to a shader:
                        <ol>
                            <li>The Vertex shader</li>
                            <li>The Fragment shader</li>
                        </ol>
                    </li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The Vertex shader defines how the geometry of the object should be rendered</li>
                    <li>The glow on this scene is just a Sphere, like everything else</li>
                    <li>Since I don't need to alter the shape of the object, the Vertex shader here just renders it "as is"</li>
                </ul>
<pre><code class="c">
    varying vec3 vNormal;
    void main(){
        vNormal = normalize(normalMatrix * normal);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1);
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Fragment shaders define how each pixel should be rendered, after the Vertex shader has defined it's geometry</li>
                    <li>For our glow, it's a bit more interesting than the Vertex shader</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>What our Fragment shader is doing here is first calculating the intensity of the pixel, based on the z-position of it's normal</li>
                    <li>Or, the dot product of it's Normal and a Vector of 0,0,1, to the power of 3</li>
                    <li>The 'dot product' is an operation that takes two Vectors of equal length and produces a single number</li>
                    <li>By calculating the dot product of the Normal and a Vector of 0,0,1, we end up with just the Z position</li>
                    <li>So - the intensity is the Z position relative to the origin of the sphere, cubed</li>
                    <li>Or - the intensity is the distance of the pixel from the center, with a cubic falloff</li>
                    <li>This is then used to calculate the colour of the pixel. The further away from the center, the darker and more opaque the pixel</li>
                    <li>Which gives us a 'glow' effect!</li>
                </ul>
<pre><code class="c">
    varying vec3 vNormal;
    void main(){
        float intensity = pow( dot(vNormal, vec3(0.0, 0.0, 1.0)), 3);
        gl_FragColor = vec4(0.7, 0.8, 1.0, 1.0) * intensity;
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Don't worry if you don't understand all the maths in that. I don't really get it either!</li>
                    <li>Reading up a bit on Cartesian and Euclidean theory doesn't hurt, but for most things in Three.js you don't need to</li>
                    <li>Most of the time you can find a shader online and alter it to your needs</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Importing Meshes</h2>
    </section>
    <section>
        <iframe data-src="../importing-objects/importing-objects.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Importing objects</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>A horse!</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Importing objects into your Three.js scenes is very easy!</li>
                    <li>Building an object like this in Three.js would be very hard</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>If you need complicated objects like this, it's best to model them in a 3D modelling package and export them</li>
                    <li>Anything that can export .obj files will be fine</li>
                    <li>For example, Blender is a free, cross platform app with an active community and plenty of tutorials</li>
                    <li>Or you can do what I've done here, and download the obj from a repository on the internet</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Once you've downloaded or exported your .obj file, there's a python script that comes with Three.js which can convert it for you</li>
                    <li>This script can be found in the Three.js Github repo, currently under /utils/converters/obj</li>
                </ul>
<pre><code class="bash">
    python convert_obj_three.py -i horse.obj -o horse.js

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>When you have your horse.js file, use a THREE.JSONLoader to import it</li>
                    <li>Here's the complete source for this scene:</li>
                </ul>
<pre><code class="js">
    var jsonLoader = new THREE.JSONLoader();
    var file = 'horse.js';

    jsonLoader.load(file, function(geometry, materials){
        var wireframeMaterial = new THREE.MeshBasicMaterial({
            color: 0xff0000,
            wireframe: true
        });
        var mesh = new THREE.Mesh(geometry, wireframeMaterial);

        mesh.scale.set(7, 7, 7);

        scene.add(mesh);
    });

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../importing-objects/importing-objects-textured.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Using imported textures</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>In the previous example I've set the material to a wireframe so it's easier to see the imported geometry</li>
                    <li>But the output of the converter will also include materials, if they are present</li>
                    <li>Using these is pretty easy, but I've found it's a little buggy</li>
                    <li>Sometimes they don't work at all, sometimes the textures aren't included, and so on</li>
                    <li>Fortunately for the horse I prepared earlier, the textures came over fine</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The materials are passed to the callback from JSONLoader.load as an array</li>
                </ul>
<pre><code class="js">
    jsonLoader.load(file, function(geometry, materials){

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>If your object only has one material you can just pass the first item of the array to your new THREE.Mesh:</li>
                </ul>
<pre><code class="js">
    var mesh = new THREE.Mesh(geometry, materials[0]);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>If like the horse, it has multiple materials, you can use the "createMultiMaterialObject" utility</li>
                    <li>As you've probably guessed, this creates a mesh from a geometry and applies multiple materials to it</li>
                </ul>
<pre><code class="js">
    var mesh = THREE.SceneUtils.createMultiMaterialObject(geometry, materials);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>So here's the complete code for our textured horse:</li>
                </ul>
<pre><code class="js">
    var light = new THREE.SpotLight();
    light.position.set(500, 500, 500);
    scene.add(light);

    var jsonLoader = new THREE.JSONLoader();
    var file = 'horse.js';

    jsonLoader.load(file, function(geometry, materials){
        var mesh = THREE.SceneUtils.createMultiMaterialObject(geometry, materials);
        
        mesh.scale.set(7, 7, 7);

        scene.add(mesh);
    });

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Improved Sandboxes and Dev Tools</h2>
    </section>
    <section>
        <iframe data-src="../improved-sandbox/improved-boilerplate.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>An improved sandbox</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Adjusting Three.js scenes can be <i>hard</i></li>
                    <li>Even small adjustments to e.g.: your camera or light position can have a big effect</li>
                    <li>Changing values in the code and reloading the scene each time can be quite slow</li>
                    <li>So we need to use something a little more interactive</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Dat.gui is great for this</li>
                    <li>It's a "lightweight graphical user interface for changing variables in JavaScript"</li>
                    <li>The controls on the right hand side are built with dat.gui</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>To use dat.gui, first you create a config map with the values that you want to control</li>
                </ul>
<pre><code class="js">
    var config = {
        'rotation': true,
        'rotationSpeed': 0.01,
        'cameraDistance': 200,
        'cameraX': 150,
        'cameraY': 80,
        'cameraZ': -10,
        'ambient': 0x111111,
        'spotlight': 0xE9C2A6,
        'spotlightX': 100,
        'spotlightY': 100,
        'spotlightZ': -100
    };

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Then, pass this config to your Sandbox</li>
                </ul>
<pre><code class="js">
    var sandbox = new Sandbox({
        controls: controls
    });

    ...

    function Sandbox(options){
        this.controls = options.controls;

        this.ambient = new THREE.AmbientLight(this.controls.ambient, 1);
        this.spotlight = spotlight(
            this.controls.spotlight,
            this.controls.spotlightX,
            this.controls.spotlightY,
            this.controls.spotlightZ
        );
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>You'll need to update your Sandbox on each render tick, in case the values have changed:</li>
                </ul>
<pre><code class="js">
    Sandbox.prototype.animate = function(){
        var camera = this.camera;
        var controls = this.controls;
        var ambient = this.ambient;
        var spotlight = this.spotlight;
        var numTicks = 0;

        function tick(){
            requestAnimationFrame(tick);

            ambient.color = new THREE.Color(controls.ambient);
            spotlight.position.set(controls.spotlightX, controls.spotlightY, controls.spotlightZ);
            spotlight.color = new THREE.Color(controls.spotlight);

            if(controls.rotation){
                rotateCamera(camera, controls, numTicks);
                numTicks++;
            }else{
                positionCamera(camera, controls);
            }
        }
        tick();
    };

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>At this point everything is ready for the values in config to change</li>
                    <li>They're passed by reference, so changing config values outside Sandbox will update the values in Sandbox</li>
                    <li>This is where dat.gui comes in!</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>First make a function to wrap your config</li>
                </ul>
<pre><code class="js">
    function datControls(){
        var config = {
            'rotation': true,
            'rotationSpeed': 0.01,
            'cameraDistance': 200,
            'cameraX': 150,
            'cameraY': 80,
            'cameraZ': -10,
            'ambient': 0x111111,
            'spotlight': 0xE9C2A6,
            'spotlightX': 100,
            'spotlightY': 100,
            'spotlightZ': -100
        };

        return config;
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Then, weave it through dat.gui</li>
                    <li>Creating the new dat.GUI will inject it's DOM into the page for you</li>
                    <li>Booleans just need adding to the config, Numbers need a range, and colours have their own addColour method</li>
                </ul>
<pre><code class="js">
    function datControls(){
        var gui = new dat.GUI();
        var config = {
            'rotation': true,
            'rotationSpeed': 0.01,
            'cameraDistance': 200,
            'cameraX': 150,
            'cameraY': 80,
            'cameraZ': -10,
            'ambient': 0x111111,
            'spotlight': 0xE9C2A6,
            'spotlightX': 100,
            'spotlightY': 100,
            'spotlightZ': -100
        };

        gui.add(config, 'rotation');
        gui.add(config, 'rotationSpeed', -0.1, 0.1);
        gui.addColor(config, 'ambient');

        return config;
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>You can create folders with dat.gui to group parts of the config together</li>
                </ul>
<pre><code class="js">
    function datControls(){
        var gui = new dat.GUI();
        var config = {
            ...
        };

        var f0 = gui.addFolder('Camera rotation');
        f0.add(config, 'rotation');
        f0.add(config, 'rotationSpeed', -0.1, 0.1);
        f0.add(config, 'cameraDistance', 0, 1000);
        f0.open();

        ...

        return config;
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../improved-sandbox/fps.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Measuring FPS</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Measuring the number of frames per second that your scenes render at is even easier</li>
                    <li>Mr Doob has another project on Github called "Stats.js"</li>
                    <li>This is imported using a script tag like Three.js</li>
                </ul>
<pre><code class="html">
    &lt;script src="stats.min.js"&gt;&lt;/script&gt;

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Once it's been imported, the constructor is available as 'Stats' on the global object</li>
                    <li>You'll need to append the stats dom node to your document</li>
                </ul>
<pre><code class="js">
    var stats = new Stats();

    document.body.appendChild(stats.domElement);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>On each tick simply call stats.begin before your render</li>
                    <li>And stats.end after your render</li>
                </ul>
<pre><code class="js">
        function tick(){
            requestAnimationFrame(tick);

            stats.begin();
            sandbox.render();
            stats.end();
        }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Lighting</h2>
    </section>
    <section>
        <iframe data-src="../lighting/shadows.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Shadows</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Spotlights are probably the type of light you will use the most</li>
                    <li>As we saw earlier, Spotlights have a position and shine a cone of light on a target</li>
                </ul>
<pre><code class="js">
    light.position.set(1000, 1000, 1000);
    light.target.set(0, 0, 0);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>It is also possible for a Spotlight (or any directional light) to cast shadows</li>
                    <li>To enable shadows, enable the 'castShadow' property on the light</li>
                </ul>
<pre><code class="js">
    light.castShadow = true;

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Each mesh in your scene will also need to be told to cast a shadow, and to receive a shadow</li>
                    <li>These are both off by default</li>
                </ul>
<pre><code class="js">
    mesh.castShadow = true;
    mesh.receiveShadow = true;

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>If your shadow doesn't look very crisp, update the shadowmap resolution</li>
                    <li>This is controlled by the shadowMapWidth and shadowMapHeight properties</li>
                    <li>These values must be a power of 2!</li>
                </ul>
<pre><code class="js">
    light.shadowMapWidth = 1024;
    light.shadowMapHeight = 1024;

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>The darkness of your shadow can be controlled with the "shadowDarkess" property</li>
                </ul>
<pre><code class="js">
    light.shadowDarkness = 0.4;

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Finally, you can enable the "camera frustrum" on the light</li>
                    <li>This allows you to see the boundaries of the light cone</li>
                    <li>Useful for debugging!</li>
                </ul>
<pre><code class="js">
    light.shadowCameraVisible = true;

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>So, here's everything you need for a decent shadow:</li>
                </ul>
<pre><code class="js">
    light.castShadow = true;
    light.shadowMapWidth = 1024;
    light.shadowMapHeight = 1024;
    light.shadowDarkness = 0.4;

    ...

    mesh.castShadow = true;
    mesh.receiveShadow = true;

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
    </section>
    <section>
        <iframe data-src="../lighting/directional.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Directional Lights</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Directional lights are similar to SpotLights, but without a light cone</li>
                    <li>Light is mapped as a plane moving from the light position to the target position</li>
                    <li>Apart from this difference, Directional lights have almost all the same properties as SpotLights</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>DirectionalLights only take 2 arguments - the colour and intensity</b></li>
                </ul>
<pre><code class="js">
    var light = new THREE.DirectionalLight(colour, intensity);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../lighting/ambient.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Ambient Lights</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Ambient lights apply their colour to all surfaces of objects in the scene equally</li>
                    <li>They take only 1 argument - the colour</li>
                </ul>
<pre><code class="js">
    var light = new THREE.AmbientLight(colour);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>I've removed the plane / floor in this example</li>
                    <li>Otherwise, you wouldn't be able to see the objects!</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>AmbientLights are best used to lighten your scene globally very slightly</li>
                    <li>If the colour is too intense they will overpower all your other lights</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../lighting/hemispherelight.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Hemisphere Lights</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Hemisphere lights are similar to Directional lights, except their light is mapped as a hemisphere rather than a plane</li>
                    <li>This gives a softer, more "sun-like" effect</li>
                    <li>Hemisphere lights also have a ground colour</li>
                    <li>This gives an uplight effect in the opposite direction to the main light</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../lighting/point.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Point Lights</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Point lights are a bit like light bulbs</li>
                    <li>They have a position, but no target, and shine in all directions</li>
                    <li>The distance property controls how far they shine</li>
                    <li>Quite fun to use on particles!</li>
                </ul>
<pre><code class="js">
    var light = new THREE.PointLight(colour, intensity, distance);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Combining Lights</h2>
    </section>
    <section>
        <iframe data-src="../combined-lighting/sunlight.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Sunlight</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>
                        For a decent sunlight effect we'll need to use two lights:
                        <ol>
                            <li>A hemisphere light for the general effect</li>
                            <li>A directional light for shadows</li>
                        </ol>
                    </li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>I've made the two lights toggleable in the controls</li>
                    <li>If we turn off the Directional light you can see that the shadow is removed</li>
                    <li>But the model retains the sky and ground lighting</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>If we turn off the Hemisphere light, we get the shadows but the model is harder to see</li>
                    <li>Especially on the underside where the directional light does not affect it</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>In most of your scenes, you'll need to use at least two lights</li>
                    <li>Lighting can be tricky to get right</li>
                    <li>It's advisable to use dat.gui to find the optimimum values before setting them in stone</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../combined-lighting/threepoint.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Three Point lighting</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Three-point lighting is one of the standard setups for lighting used in theatre, video and film</li>
                    <li>It allows you to illuminate your object, while giving you a lot of control over the shading and shadows in the scene</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>
                        The three lights are known as:
                        <ol>
                            <li>The <i>key light</i> - which shines directly upon the object</li>
                            <li>The <i>fill light</i> - which shines to the side of the object, and balances the key light</li>
                            <li>The <i>back light</i> - which separates the object from the background, and helps to highlight contours</li>
                        </ol>
                    </li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>By toggling the lights on and off you can see how each one contributes to the lighting of the scene</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Animating Geometries</h2>
    </section>
    <section>
        <iframe data-src="../animating-geometries/terrain.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Building the flat terrain</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>For this example we'll make an MP3 visualiser</li>
                    <li>First off we'll need a flat terrain to animate</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the code for our terrain, it's just a Plane with two Phong materials, one for the main colour and one for the wireframe:</li>
                </ul>
<pre><code class="js">
    function makePlane(colours){
        var geometry = new THREE.PlaneGeometry(1000, 1000, 128, 128);
        var material  = new THREE.MeshPhongMaterial({
            color: 0xFF69B4
        });
        var wireframeMaterial  = new THREE.MeshPhongMaterial({
            color: 0x000000,
            wireframe: true
        });
        var mesh = new THREE.SceneUtils.createMultiMaterialObject(geometry, [
            material,
            wireframeMaterial
        ]);

        mesh.rotation.x = -Math.PI / 2;

        return mesh;
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../animating-geometries/updating-terrain.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Animating the terrain</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>To animate the terrain, we modify it's vertices on each tick</li>
                    <li>For each vertex in the terrain's geometry, we increase or decrease it's z axis by a random amount</li>
                    <li>After we've defined the new vertex positions, we need to tell Three.js that it's vertices need updating when renderer</li>
                    <li>Otherwise, Three.js caches the geometry for us to save unecessary calculations</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's our tick function in it's entirety</li>
                </ul>
<pre><code class="js">
    function tick(){
        requestAnimationFrame(tick);

        var geometry = terrain.children[0].geometry;
        var vertices = geometry.vertices;
        var numVertices = vertices.length;
        var movementRange = 4;

        for(var i = 0; i &lt; numVertices; i++){
            vertices[i].z += Math.random() * movementRange - movementRange / 2;
        }

        geometry.verticesNeedUpdate = true;

        terrainScene.render();
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../animating-geometries/using-audio.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Using audio</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>I'm using the HTML5 Audio API here to load an MP3 and use the wave to set vertex positions</li>
                    <li>I won't go into the Audio side of things because that's a topic all by itself but it's not too hard</li>
                    <li>This piece of code is the important bit:</li>
                </ul>
<pre><code class="js">
    var audio = new AudioData({
        src: 'mp3/minuit-jacuzzi.mp3',
        width: 256,
        onTick: function(buffer){
            terrain.update(buffer);
        }
    });

</code></pre>
                <ul>
                    <li>On every tick of Audio stream, the buffer is passed to the 'update' method of our Terrain object</li>
                    <li>The Terrain object is just a wrapper around the plane we created earlier</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>So, on every tick of the <i>Audio stream</i>, we update the vertex positions of our terrain based on the audio buffer</li>
                    <li>And on every tick of our <i>render loop</i>, we render the terrain with our camera</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the Terrain.update method:</li>
                </ul>
<pre><code class="js">
    Terrain.prototype.update = function(audioData){
        var geometry = this.plane.children[0].geometry;
        var vertices = geometry.vertices;
        var faces = geometry.faces;

        for(var i = 0; i &lt; audioData.length; i++){
            setFaceVelocity(vertices, faces[i], audioData[i]);
        }

        geometry.verticesNeedUpdate = true;
    };

    function setFaceVelocity(vertices, face, velocity){
        vertices[face.a].z = velocity;
        vertices[face.b].z = velocity;
        vertices[face.c].z = velocity;
    }

</code></pre>
                <ul>
                    <li>So, for every entry in the audio buffer / waveform</li>
                    <li>Increase each vertex of the corresponding face in the geometry</li>
                    <li>By the value of that entry in the waveform</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Our terrain is 128 faces wide and 128 faces high</li>
                    <li>The Audio buffer is 128 units long</li>
                    <li>So the only affected faces in our geometry are the first 128</li>
                    <li>Therefore, only one line of faces in our geometry is animated</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../animating-geometries/smearing.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>The next thing we'll need to do is to move the affected faces along the terrain</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The simplest way to do this is to copy the vertices of each line onto the next on each tick</li>
                    <li>I've added this to the Terrain object, as the "smearDown" method</li>
                </ul>
<pre><code class="js">
    var audio = new AudioData({
        src: 'mp3/minuit-jacuzzi.mp3',
        width: 256,
        onTick: function(buffer){
            terrain.update(buffer);
            terrain.smearDown();
        }
    });

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the code for Terrain.smearDown</li>
                </ul>
<pre><code class="js">
    Terrain.prototype.smearDown = function(){
        var geometry = this.plane.children[0].geometry;
        var vertices = geometry.vertices;
        var faces = geometry.faces;

        for(var i = faces.length - 1; i >= this.width; i--){
            var aVelocity = vertices[faces[i - this.width].a].z;
            var bVelocity = vertices[faces[i - this.width].b].z;
            var cVelocity = vertices[faces[i - this.width].c].z;
            var avgVelocity = (aVelocity + bVelocity + cVelocity) / 3;
            setFaceVelocity(vertices, faces[i], avgVelocity);
        }

        geometry.verticesNeedUpdate = true;
    };

</code></pre>
                <ul>
                    <li>Working backwards from the end of our geometry, up to the "active" line of our geometry</li>
                    <li>Average out the z positions of each face's vertices on the previous line (I've called this the "velocity")</li>
                    <li>And apply this to the vertices of this face</li>
                    <li>Averaging it out causes peaks to smooth out as they move along the terrain</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../animating-geometries/complete.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>The completed visualiser!</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <!--section class="intro">
        <h2>Reflection</h2>
    </section>
    <section>
        <iframe data-src="http://dan.nea.me/reflection" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Reflection</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section-->

    <section class="intro">
        <h2>Particles</h2>
    </section>
    <section>
        <iframe data-src="../particles/particle-sphere.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Particles</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Particles are a lot easier to work with than you might think</li>
                    <li>In Three.js, Particles are just vertices on a Geometry</li>
                    <li>There's a special Material type called "PointCloudMaterial" that can be used to render each vertex as a point</li>
                    <li>And instead of creating a Mesh, you create a ParticleSystem</li>
                </ul>
<pre><code class="js">
    function particleSphere(){
        var geometry = new THREE.SphereGeometry(120, 16, 12);
        var material = new THREE.PointCloudMaterial({
            size: 5,
            color: 0x339900
        });
        var system = new THREE.ParticleSystem(geometry, material);

        system.position.y = 100;

        return system;
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>You can't alter Geometries on the fly, so you need to start your scene with all your particles present</li>
                    <li>What you can do to get around this, is to have all the particles / vertices set to one position or off screen</li>
                    <li>So they either all render as a single pixel, or you just don't see them at all</li>
                    <li><i>OR</i> you can rebuild your ParticleSystem on each tick - this is prohibitively expensive, though!</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../particles/particlebox.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>The "Particle Box"</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>What I've done here is generate a Geometry programatically</li>
                    <li>This Geometry is then used for a ParticleSystem</li>
                    <li>The particles are initially placed in the bottom corner of the box</li>
                    <li>We'll cover the tick() method next</li>
                </ul>
<pre><code class="js">
    function createParticles(boxSize){
        var numActiveParticles = 0;
        var totalParticles = 20000;
        var geometry = new THREE.Geometry();
        var material = new THREE.PointCloudMaterial({
            size: 2,
            color: 0x339900
        });

        for(var i = 0; i &lt; totalParticles; i++){
            var bottomCorner = new THREE.Vector3(-boxSize/2, -boxSize/2, -boxSize/2);
            geometry.vertices.push(bottomCorner);
        }

        function tick(){
            // see next slide
        }
        requestAnimationFrame(tick);

        return new THREE.ParticleSystem(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Now for the tick method</li>
                    <li>This controls both 'firing' the particles from their starting point</li>
                    <li>And moving each particle based on it's velocity</li>
                    <li>Particles are fired one after the other until all particles are active</li>
                </ul>
<pre><code class="js">
    function tick(){
        requestAnimationFrame(tick);

        if(numActiveParticles &lt; totalParticles){
            fireParticle(geometry.vertices[numActiveParticles]);
            numActiveParticles++;
        }

        moveParticles(geometry.vertices, boxSize);
        geometry.verticesNeedUpdate = true;
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>
                        The fireParticle function simply sets two properties on the particle passed:
                        <ol>
                            <li>An 'active' property</li>
                            <li>An initial 'velocity', in 3 dimensions</li>
                        </ol>
                    </li>
                </ul>
<pre><code class="js">
    function fireParticle(vertex){
        vertex.active = true;
        vertex.velocity = new THREE.Vector3(0, 0, 0);
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>moveParticles is a bit more interesting</li>
                    <li>It loops over every particle in the geometry, skipping any that aren't active</li>
                    <li>Then adds the 'worldAccelleration' vector to the particle's velocity</li>
                    <li>Once the velocity has been calculated, the particle's position is increased by it's velocity</li>
                    <li>That means that on each tick, it's velocity is increased by the acceleration</li>
                    <li>And it's position is increased by it's velocity</li>
                    <li>Then it calls a bounceParticle method to ensure the particle hasn't gone outside the box</li>
                </ul>
<pre><code class="js">
    function moveParticles(particles, boxSize){
        
        var worldAccelleration = new THREE.Vector3(0.01, 0.02, 0.04);

        for(var i = 0; i &lt; particles.length; i++){
            var particle = particles[i];
            
            if(!particle.active){
                continue;
            }

            particle.velocity.add(worldAccelleration);

            particle.x += particle.velocity.x;
            particle.y += particle.velocity.y;
            particle.z += particle.velocity.z;

            bounceParticle(particle, boxSize);
        }
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>bounceParticle calls bounceAxis for each dimension in 3D space</li>
                    <li>bounceAxis first checks to see if the particle's position is outside of the box in the given axis</li>
                    <li>If it is outside the box, it reverses the velocity of the particle in that axis</li>
                    <li>In other words, it bounces it on that axis</li>
                    <li>It also slows the particle down by 20% - simulating friction</li>
                </ul>
<pre><code class="js">
    function bounceParticle(particle, size){
        bounceAxis(particle, 'x', size);
        bounceAxis(particle, 'y', size);
        bounceAxis(particle, 'z', size);
    }

    function bounceAxis(particle, axis, size){
        var halfsize = size / 2;
        if(particle[axis] &gt; -halfsize && particle[axis] &lt; halfsize){
            return; // do nothing - it's inside the box
        }
        particle.velocity[axis] = -particle.velocity[axis];
        particle.velocity.multiplyScalar(0.8);
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>
                        So to summarise:
                        <ol>
                            <li>We create a Geometry with all of it's vertices in one place - these vertices are our particles</li>
                            <li>Every tick, we fire one particle off and move any that have been fired</li>
                            <li>Each active particle has it's velocity increased by the world accelleration</li>
                            <li>Each active particle has it's position increased by it's velocity</li>
                            <li>And each particle is bounced off the edge of the box it's in and slowed down, if it's outside the box</li>
                        </ol>
                    </li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Voxels</h2>
    </section>
    <section>
        <iframe data-src="../voxels/basic.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>"Voxel" is a portmanteau of "Volume" and "Pixel"</li>
                    <li>Basically, they are Boxes used to create more complicated geometries</li>
                    <li>They've been used more frequently in games since the advent of Minecraft</li>
                    <li>In this section we'll see how you can make your own Minecraft-like game</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>First off we'll need a function that can draw our Voxels at given positions</li>
                    <li>Note that the dimensions and position are based on a 'voxel size'</li>
                    <li>The x, y, z coordinates we pass the function refer to "Voxel space", not Cartesian coordinates</li>
                </ul>
<pre><code class="js">
    var voxelSize = 20;
    function voxel(x, y, z){
        var geometry = new THREE.BoxGeometry(voxelSize, voxelSize, voxelSize);
        var material = new THREE.MeshLambertMaterial({
            map: THREE.ImageUtils.loadTexture('img/minecraft_brick.jpg')
        });
        var mesh = new THREE.Mesh(geometry, material);

        mesh.position.set(voxelSize * x, voxelSize * y + voxelSize / 2, voxelSize * z);

        return mesh;
    }

    ...

    sandbox.add(voxel(0, 0, 0));

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../voxels/floor.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Since our voxel method takes coordinates in "Voxel space", we can build maps to programatically add voxels</li>
                    <li>Here's how we'd define an 8x8 'floor' map</li>
                </ul>
<pre><code class="js">
    var floor = [
        [1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1]
    ];

</code></pre>
                <ul>
                    <li>It's pretty simple, all we do is fill in each entry in the array with a 1</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>We can then iterate over this 2D array to add the voxels at their given positions</li>
                    <li>I've used a THREE.Group here to group the voxels together</li>
                    <li>This allows you to treat the voxels generated by iterating over the floor array as a single object</li>
                </ul>
<pre><code class="js">
    var houseGroup = new THREE.Group();
    
    floor.forEach(function(row, rowNum){
        row.forEach(function(point, pointNum){
            if(point === 1){
                houseGroup.add(voxel(rowNum, 0, pointNum));
            }
        });
    });

    houseGroup.position.x = -45;
    houseGroup.position.z = -45;

    sandbox.add(houseGroup);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../voxels/house.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>So, we've done 1 dimension (a point or single voxel), 2 dimensions (our floor), now let's do 3 dimensions (a house)</li>
                    <li>It's easy to do - we define additional 8x8 maps for each slice of the house we want</li>
                    <li>Wherever we need a voxel, put a 1, and where we want empty space, put a 0</li>
                    <li>For example, here's a wall for our house, with space for a door:</li>
                </ul>
<pre><code class="js">
    var wall = [
        [1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 0, 0, 1, 1, 1]
    ];

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>After we've defined our different slice types, it's simply a case of joining them together to form a building</li>
<pre><code class="js">
    var house = [floor, wall, wallWithWindow, wallWithWindow, wallWithoutDoor, floor, roof, chimney, chimney];

</code></pre>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>We need to change our Group builder slightly to allow for the additional dimension, but everything else stays the same</li>
<pre><code class="js">
    house.forEach(function(slice, sliceNum){
        slice.forEach(function(row, rowNum){
            row.forEach(function(point, pointNum){
                if(point === 1){
                    houseGroup.add(voxel(rowNum, sliceNum, pointNum));
                }
            });
        });
    });

</code></pre>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../voxels/house-explode.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Since these are voxels and not a solid object, you can treat them a bit like particles</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../voxels/complete.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>And here's one I made earlier!</li>
                    <li>I've used the 'FlyControls' to allow you to walk around, which are under 'plugins' in the Three.js repo</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Fin</h2>
        <h3>Dan Neame <a href="https://twitter.com/cham">@cham</a></h3>
        <h3><a href="http://dan.nea.me">dan.nea.me</a></h3>
    </section>


    <script src="highlight.min.js"></script>
    <script src="slideshow.js"></script>
  </body>
</html>
