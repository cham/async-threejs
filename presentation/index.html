<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>A simple scene</title>
    <link href="http://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Reenie+Beanie" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="highlight.min.css">
    <style>
    html {
        height: 100%;
        font-family: sans-serif;
    }
    h2 {
        font-size: 2.5em;
        font-weight: normal;
        font-style: italic;
    }
    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
        font-size: 1.3em;
        font-family: Roboto, sans-serif;
    }
    iframe , section {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border: 0;
        z-index: 0;
    }
    section {
        display: none;
    }
    ul {
        padding: 0;
        margin: 0;
    }
    ul li {
        list-style-type: none;
    }
    ul ol li {
        list-style-type: decimal;
    }
    .content {
        z-index: 1;
        position: absolute;
        top: 0;
        left: 0;
        background: #333;
        color: #fff;
        display: none;
    }
    .transitionable {
        transition: left 0.75s ease-in-out;
    }
    .subsection {
        padding: 12px;
        display: none;
    }
    .content .subsection:first-of-type {
        display: block;
    }
    .intro {
        background: #69f;
        font-family: 'Reenie Beanie', serif;
        height: 100%;
        text-align: center;
    }
    .intro h2 {
        position: relative;
        top: 50%;
        transform: translateY(-50%);
        color: #fff;
    }
    .always-invisible {
        visibility: hidden;
        padding: 0;
    }
    </style>
  </head>
  <body>
    <section class="intro">
        <h2>A simple scene</h2>
    </section>
    <section>
        <iframe data-src="../lights-camera-objects/a-simple-scene.html" width="100%" height="100%" wmode="transparent"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Scenes are containers for your three.js objects</li>
                    <li>You <i>can</i> have multiple scenes, but usually you only need one</li>
                </ul>
<pre><code class="js">
    var scene = new THREE.Scene(); // fill me with stuff!

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>We'll need a camera to take pictures of our scene</li>
                    <li>As with scenes, you'll often only need one of these</li>
                    <li>There are a few different types of camera, but PerspectiveCamera will give you a 'natural' look</li>
                    <li>It takes 4 arguments - the field of view, the view aspect, the 'near' cutoff and the 'far' cutoff</li>
                    <li>If you don't need to specify an argument, leave it out to use the default value</li>
                </ul>
<pre><code class="js">
    var wSize = windowSize();
    var camera = new THREE.PerspectiveCamera(40, wSize.width / wSize.height);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>The renderer renders the objects in our scene to the screen</li>
                    <li>There are 3 renderers - CSS, Canvas and WebGL</li>
                    <li>We'll only deal with the WebGL renderer for this talk</li>
                </ul>
<pre><code class="js">
    var renderer = new THREE.WebGLRenderer();

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Now that we have our scene, camera and renderer, we set the size of the renderer...</li>
                    <li>Execute a render, specifying the scene we want to render and the camera to render with...</li>
                    <li>and append the domElement of the renderer to the body of our HTML document</li>
                </ul>
<pre><code class="js">
    renderer.setSize(wSize.width, wSize.height);
    renderer.render(scene, camera);

    document.body.appendChild(renderer.domElement);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>The exciting result is an empty screen, as we've not added anything to our scene yet!</li>
                    <li>You can change the background colour of our render via renderer.setClearColor(hex);</li>
                </ul>
<pre><code class="js">
    renderer.setClearColor(0xff6699);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the code in it's entirety, it's running in the background right now</li>
                </ul>
<pre><code class="js">
    function windowSize(){
        return {
            width: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
            height: Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
        };
    }

    var wSize = windowSize();

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(40, wSize.width / wSize.height);
    var renderer = new THREE.WebGLRenderer();

    renderer.setClearColor(0xff6699);
    renderer.setSize(wSize.width, wSize.height);
    renderer.render(scene, camera);

    document.body.appendChild(renderer.domElement);

</code></pre>
        </div>
    </section>

    <section class="intro">
        <h2>A less simple scene</h2>
    </section>
    <section>
        <iframe data-src="../lights-camera-objects/a-less-simple-scene.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Our scene works but is a bit boring, there's nothing in it!</li>
                    <li>let's add a sphere to start</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Meshes in Three are composed of two things - Geometry and one or more Materials</li>
                    <li>Think of geometry as the shape and material as the paint</li>
                    <li>When these are combined, we have a Mesh that can be added to the scene</li>
                </ul>
<pre><code class="js">
    var mesh = new THREE.Mesh(geometry, material);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Spheres take 7 arguments, for a basic sphere you only need the first argument - the radius</li>
                    <li>The next two arguments define the number of horizontal and vertical segments</li>
                    <li><small>(the next four are used to make sphere segments, if you just want a part of a sphere)</small></li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.SphereGeometry(50, 16, 16);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>After we have defined our Geometry, it's time to paint it with a Material</li>
                    <li>MeshBasicMaterial defines a basic material</li>
                    <li>This material type does not require lighting, and simply paints it the colour we've specified</li>
                    <li>Materials take a bunch of options - I'm not going to cover them all, the docs are pretty comprehensive</li>
                </ul>
<pre><code class="js">
    var material = new THREE.MeshBasicMaterial({color: 0x00ff00});

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's our complete sphere() function</li>
                </ul>
<pre><code class="js">
    function sphere(){
        var geometry = new THREE.SphereGeometry(50, 16, 16);
        var material = new THREE.MeshBasicMaterial({color: 0x00ff00});

        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>To add it to the scene, we use scene.add</li>
                </ul>
<pre><code class="js">
    scene.add(sphere());

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>And we'll need to move the camera out a bit, so it's not inside the sphere</li>
                </ul>
<pre><code class="js">
    camera.position.set(0, 0, 300);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>It looks like a circle since the basic material does not show any shading</li>
                    <li>If we turn on wireframes then it's a bit clearer what's going on</li>
                    <li><small>Some live coding here! Or edit a-less-simple-scene.html to the following:</small></li>
                </ul>
<pre><code class="js">
    function sphere(){
        var geometry = new THREE.SphereGeometry(50, 16, 16);
        var material = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true
        });

        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the code for our less simple scene</b></li>
                </ul>
<pre><code class="js">
    function sphere(){
        var geometry = new THREE.SphereGeometry(50, 16, 16);
        var material = new THREE.MeshBasicMaterial({color: 0x00ff00});

        return new THREE.Mesh(geometry, material);
    }

    var wSize = windowSize();

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(40, wSize.width / wSize.height);
    var renderer = new THREE.WebGLRenderer();

    scene.add(sphere());

    camera.position.set(0, 0, 300);

    renderer.setClearColor(0xffffff);
    renderer.setSize(wSize.width, wSize.height);
    renderer.render(scene, camera);

    document.body.appendChild(renderer.domElement);

</code></pre>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>A lit scene</h2>
    </section>
    <section>
        <iframe data-src="../lights-camera-objects/a-lit-scene.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>If we want anything other than basic materials then we're going to need some lights</li>
                    <li>There are a bunch of different lights in Three that all work in different ways</li>
                    <li>In this example we'll use a SpotLight</li>
                </ul>
<pre><code class="js">
    var light = new THREE.SpotLight();

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Spotlights have a <b>position</b> and shine a cone of light on a <b>target</b></li>
                    <li>The target will be 0, 0, 0 by default, but I've included it for reference</li>
                </ul>
<pre><code class="js">
    light.position.set(1000, 1000, 1000);
    light.target.set(0, 0, 0);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>SpotLights take up to 5 arguments:</b></li>
                    <li>Their colour</li>
                    <li>Their intensity</li>
                    <li>The distance they illuminate to (default 0 = infinity)</li>
                    <li>The angle of the light cone</li>
                    <li>The falloff rate, if distance is not 0</li>
                </ul>
<pre><code class="js">
    var light = new THREE.SpotLight(0xff0000, 0.8, 500, 90, 2);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>I've changed the material the sphere uses to a Lambert material, so that the light affects it</li>
                    <li>I'll cover materials in more detail later</b></li>
                </ul>
<pre><code class="js">
    function sphere(){
        var geometry = new THREE.SphereGeometry(50, 16, 16);
        var material = new THREE.MeshLambertMaterial({color: 0x00ff00});

        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the code for our lit scene</b></li>
                </ul>
<pre><code class="js">
    function sphere(){
        var geometry = new THREE.SphereGeometry(50, 16, 16);
        var material = new THREE.MeshLambertMaterial({color: 0x00ff00});

        return new THREE.Mesh(geometry, material);
    }

    var wSize = windowSize();

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(40, wSize.width / wSize.height);
    var renderer = new THREE.WebGLRenderer();
    var light = new THREE.SpotLight();

    scene.add(sphere());
    scene.add(light);

    camera.position.set(0, 0, 300);
    light.position.set(1000, 1000, 1000);

    renderer.setClearColor(0xffffff);
    renderer.setSize(wSize.width, wSize.height);
    renderer.render(scene, camera);

    document.body.appendChild(renderer.domElement);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Object Positions</h2>
    </section>
    <section>
        <iframe data-src="../lights-camera-objects/multiple-spheres.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>It's straightforward to add multiple spheres to our scene</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>I've added a new function called "randomlyPositionedSphere"</li>
                    <li>This function calls sphere() as with our last example, but also sets the position of our sphere</li>
                    <li>The position is random within the range specified with maxPosition, in all three axes</li>
                </ul>
<pre><code class="js">
    function randomlyPositionedSphere(maxPosition){
        var mesh = sphere();

        mesh.position.set(
            (Math.random() * maxPosition) - (maxPosition / 2),
            (Math.random() * maxPosition) - (maxPosition / 2),
            (Math.random() * maxPosition) - (maxPosition / 2)
        );

        return mesh;
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Then we call randomlyPositionedSphere 100 times with a for loop</li>
                </ul>
<pre><code class="js">
    for(var i = 0; i < 100; i++){
        scene.add(randomlyPositionedSphere(boxSize));
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Refreshing the page gives us a random scene each time</li>
                </ul>
            </div>
        </div>
    </section>

    <section class="intro">
        <h2>Animation, Part One</h2>
    </section>
    <section>
        <iframe data-src="../animation-basics/circular-motion.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Time for some maths!</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>To plot the path of a circle, we can use a sine and cosine wave:</li>
                    <li>A sine wave for one axis, and a cosine wave for the other</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
            <div class="subsection">
                <ul>
                    <li>If both axes use a sine wave, or both use a cosine wave, then we get a nicely eased but linear line, diagonally</li>
                    <li><small>some live coding! or change all instances of "Math.cos" to "Math.sin" in animation-basics/circular-motion.html</small></li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../animation-basics/moving-camera.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Let's look at how we can use this to give our camera a circular path</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Up to now, we've only rendered the scene once</li>
                    <li>If we're going to have animation in the scene, we'll need to render each time something changes</li>
                    <li>requestAnimationFrame will allow us to render our scene up to 60 times per second</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>We create a tick function, that:</li>
                    <li>
                        <ol>
                            <li>positions the camera</li>
                            <li>renders the scene</li>
                            <li>increments a tick counter</li>
                            <li>schedules another call to itself with requestAnimationFrame</li>
                        </ol>
                    </li>
                </ul>
<pre><code class="js">
    function tick(){
        camera.position.set(cameraX, 0, cameraZ);

        renderer.render(scene, camera);

        tickCount += 0.01;
        requestAnimationFrame(tick);
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>In order to move the camera in a circular orbit, we set the x coordinate to a position on a sine wave, and the z coordinate to a position on a cosine wave</li>
                    <li>renderer.render(scene, camera) is replaced with the following code:</li>
                </ul>
<pre><code class="js">
    var tickCount = 0;
    function tick(){
        var cameraX = boxSize * Math.cos(tickCount);
        var cameraZ = boxSize * Math.sin(tickCount);

        camera.position.set(cameraX, 0, cameraZ);
        camera.lookAt(new THREE.Vector3(0,0,0));

        renderer.render(scene, camera);

        tickCount += 0.01;
        requestAnimationFrame(tick);
    }
    tick();

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>It's necessary to tell the camera where to look after we've moved it</li>
                    <li>Without camera.lookAt, it will keep facing in the same direction when moved rather than tracking 0, 0, 0</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../animation-basics/more-complicated-paths.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>A bit more maths!</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>This is the same example as before, but I've increased the period of the x co-ordinate</li>
                    <li>x is now Math.cos(time*3) instead of Math.cos(time)</li>
                    <li>This means that we'll be drawing 3 circles per iteration in x, and 1 in y</li>
                    <li>The result of this is a helix type path</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../animation-basics/moving-camera-2.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Here's the same path applied to the camera position in our sphere scene</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The only change is the following line in tick():</li>
                </ul>
<pre><code class="js">
        var cameraX = boxSize * Math.cos(tickCount*3);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>You can come up with some really interesting paths just by modifying the period of the sine and cosine waves</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../animation-basics/moving-camera-moving-objects.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Why not have each sphere follow a sine wave?</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>sphere() now gives the geometry a random size to make things a bit more interesting</li>
                </ul>
<pre><code class="js">
   function sphere(){
        var geometry = new THREE.SphereGeometry(Math.random() * 50, 16, 16);
        var material = new THREE.MeshLambertMaterial({color: 0x00ff00});

        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>randomlyPositionedSphere assigns a random "speed" Vector to each mesh</li>
                    <li>Vector3 is a simple object that represents a three dimensional Vector</li>
                    <li>You can use them for anything, but representing x, y and z is the most common case</li>
                </ul>
<pre><code class="js">
    function randomlyPositionedSphere(maxPosition){
        var mesh = sphere();

        mesh.position.set(
            (Math.random() * maxPosition) - (maxPosition / 2),
            (Math.random() * maxPosition) - (maxPosition / 2),
            (Math.random() * maxPosition) - (maxPosition / 2)
        );

        mesh.speed = new THREE.Vector3(
            Math.random() * 10 - 5,
            Math.random() * 10 - 5,
            Math.random() * 10 - 5
        );


        return mesh;
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>And on each tick(), we call moveSphere for each sphere in the scene:</li>
                </ul>
<pre><code class="js">
    function moveSphere(mesh, count){
        mesh.position.x += Math.sin(count) * mesh.speed.x;
        mesh.position.y += Math.sin(count) * mesh.speed.y;
        mesh.position.z += Math.sin(count) * mesh.speed.z;
    }

    ...

    function tick(){
        for(var i = 0; i < 100; i++){
            moveSphere(spheres[i], tickCount);
        }
        ...
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Geometries</h2>
        <p>Update this section to note that all arguments for all geometries are optional</p>
    </section>
    <section>
        <iframe data-src="../objects/planes.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Planes</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Planes are one of the simplest geometries</li>
                    <li>Composed of four vertices and two faces</li>
                    <li>They have a width and height but no depth</li>
                    <li>Flat objects like this are known as 'Shapes'</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Their constructor takes width as the first argument and height as the second</li>
                    <li>The third and fourth (optional) arguments define how many width and height segments they should have respectively</li>
                </ul>
<pre><code class="js">
        var geometry = new THREE.PlaneGeometry(40, 60);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/vertices.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Vertices</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>A vertex is a point in 3d space</li>
                    <li>Geometries are composed of multiple vertices</li>
                    <li>The wireframe of an object is defined by the edges between these vertices</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Our plane has 4 vertices, which are highlighted in the example like so:</li>
                </ul>
<pre><code class="js">
    var object = plane();

    object.geometry.vertices.forEach(function(vertex){
        scene.add(positionedSphere(vertex.x, vertex.y, vertex.z));
    });

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/faces.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Faces</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>A face is an individual surface of a solid object</li>
                    <li>Faces are always flat, and usually triangles (THREE.Face3), though you can create custom geometry with square faces (THREE.Face4)</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Faces are defined by the vertices that they join together</li>
                    <li>In our face() function, we:
                        <ol>
                            <li>create a new Geometry and a basic blue Material</li>
                            <li>set the vertices of the Geometry to those passed to the function</li>
                            <li>define a single face composed of the 0th, 1st and 2nd vertex</li>
                            <li>return the Mesh</li>
                        </ol>
                    </li>
                    <li>This gives us the single blue face we see in the example</li>
                </ul>
<pre><code class="js">
    function face(vertices){
      var geometry = new THREE.Geometry();
      var material = new THREE.MeshBasicMaterial({ color: 0x0000ff });

      geometry.vertices = vertices;
      geometry.faces.push(new THREE.Face3(0, 1, 2));

      return new THREE.Mesh(geometry, material);
    }

    var object = plane();

    scene.add(
        face(object.geometry.vertices.slice(0, 3))
    );

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/boxes.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Boxes (formerly "Cubes")</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Boxes have a similar constructor to planes, but with an extra dimension for depth</li>
                    <li>As with planes, you can supply an additional arguments if you want more segments in each dimension</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.BoxGeometry(40, 50, 60);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/circles.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Circles</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Circles are circular Shapes, made out of multiple Face3s</li>
                    <li>The default number of segments is 8, but you'll probably want to up this in nearly all instances</li>
                    <li>The example here is using 16 segments instead, so it has 17 vertices and 16 faces</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The first argument passed to CircleGeometry is the radius</li>
                    <li>The second argument passed to CircleGeometry is the segment count</li>
                    <li>The third and fourth arguments (both optional) allow you to define circle sections</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.CircleGeometry(40, 16);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/spheres.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Spheres</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Spheres are three dimensional circular geometries</li>
                    <li>Each vertex is at the same distance from the center point</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Spheres in Three.js are UV Spheres</li>
                    <li>This means they are generated with a sequence of rings and segments, like a plane wrapped around a central point</li>
                    <li>You can also make Spheres using icosa-, tetra-, octa- and dodeca-hedrons</li>
                    <li>UV Spheres are easiest to map textures onto due to their correlation with planes</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>As we covered earlier, SphereGeometries take 7 arguments</li>
                    <li>For a basic sphere you only need the first argument - the radius</li>
                    <li>The next two arguments define the number of horizontal and vertical segments</li>
                    <li>The next four are used to make partial spheres</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.SphereGeometry(40, 16, 12);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/rings.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Rings</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Rings are shapes defined by two circles</li>
                    <li>An outer circle, and an inner circle that defines a hole in the middle</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The RingGeometry constructor takes 6 arguments</li>
                    <li>The first two are the radii of the outer and inner circle</li>
                    <li>The third and fourth define the number of segments</li>
                    <li>The fifth and six allow you to define partial rings</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.RingGeometry(30, 24, 16, 2);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/tori.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Tori</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Spheres are to circles as tori are to rings</li>
                    <li>Instead of defining an outer and inner radius, you define the radius of the torus, and the radius of the tube</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The TorusGeometry constructor takes 5 arguments</li>
                    <li>Interestingly, this is one less than the RingGeometry</li>
                    <li>The first argument is the radius of the torus</li>
                    <li>The second argument is the radius of the tube</li>
                    <li>The third defines the number of radial segments</li>
                    <li>The fourth defines the number of tubular segments</li>
                    <li>The fifth argument allows you to draw partial tori</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.TorusGeometry(30, 6, 8, 16);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/torusknots.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Torus Knots</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Torus Knots are pretty fun geometries that generate some interesting shapes</li>
                    <li>They are defined in a similar way to tori, in that they have a radius and a tubular radius</li>
                    <li>The twisting shape is defined by two numbers, p and q</li>
                    <li>For a torus knot to be complete, both p and q must be integers</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The constructor of a TorusKnotGeometry takes 7 arguments</li>
                    <li>
                        <ol>
                            <li>The radius</li>
                            <li>The tubular radius</li>
                            <li>The number of radial segments</li>
                            <li>The number of tubular segments</li>
                            <li>p</li>
                            <li>q</li>
                            <li>The height scale - how much the torusknot deviates in the z axis</li>
                        </ol>
                    </li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.TorusKnotGeometry(30, 6, 64, 16);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/cylinders.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Cylinders</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Cylinders are circles extruded in the y axis</li>
                    <li>You can supply a different radius to the top and bottom of the cylinder</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>CylinderGeometry takes 6 arguments:</li>
                    <li>
                        <ol>
                            <li>The radius at the top of the cylinder</li>
                            <li>The radius at the bottom of the cylinder</li>
                            <li>The height of the cylinder</li>
                            <li>The number of radial segments</li>
                            <li>The number of height segments</li>
                            <li>A boolean denoting whether or not the cylinder is open (true) or capped (false)</li>
                        </ol>
                    </li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.CylinderGeometry(20, 20, 60);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/cones.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Cones</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>If you define one of the radii for a Cylinder as 0 then the result is a cone</li>
                    <li>Here's the same Cylinder we saw in the previous example, with a top radius of 0:</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.CylinderGeometry(0, 20, 60);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/pyramids.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Pyramids</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>A cone with three sides is a pyramid</li>
                    <li>Here's the same Cylinder we saw in the previous example, but with 3 radial segments:</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.CylinderGeometry(0, 20, 60, 3);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/all-hedrons.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Tetra-, icosa-, octa- and dodecahedrons</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>All define die-like shapes</li>
                    <li>As you increase the number of segments they become more like spheres</li>
                    <li>Better than UV Spheres if you need to alter their geometries</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>All of these geometries take 2 arguments:</li>
                    <li>
                        <ol>
                            <li>The radius of the geometry</li>
                            <li>The detail of the geometry (default 0)</li>
                        </ol>
                    </li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.TetrahedronGeometry(16);
    var geometry = new THREE.IcosahedronGeometry(16);
    var geometry = new THREE.OctahedronGeometry(16);
    var geometry = new THREE.DodecahedronGeometry(16);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/detailed-hedrons.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Detailed tetra-, icosa-, octa- and dodecahedrons</li>
                </ul>
            </div>
            <div class="subsection">
<pre><code class="js">
    var geometry = new THREE.TetrahedronGeometry(16, 2);
    var geometry = new THREE.IcosahedronGeometry(16, 2);
    var geometry = new THREE.OctahedronGeometry(16, 2);
    var geometry = new THREE.DodecahedronGeometry(16, 2);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Materials</h2>
    </section>
    <section>
        <iframe data-src="../materials/sphere-lambert-basic-phong.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Material types</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Notes: Demo contains basic, lambert and phong. This section also needs to cover Depth, Normal and Face materials. May as well leave out Line and LineDashed? Not very interesting</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-shading.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Shading types</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Phong shaded sphere</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-texturemap.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Texture maps</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-bumpmap.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Bump maps</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-specularmap.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Specular maps</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-alphamap.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Alpha maps</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-transparency.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Transparency</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-materialsides.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Material sides</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-customshader.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Custom shaders</li>
                </ul>
            </div>
        </div>
    </section>

    <section class="intro">
        <h2>Importing Meshes</h2>
    </section>
    <section>
        <iframe data-src="../importing-objects/importing-objects.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Importing objects</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../importing-objects/importing-objects-textured.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Using imported textures</li>
                </ul>
            </div>
        </div>
    </section>

    <section class="intro">
        <h2>Improved Sandboxes and Dev Tools</h2>
    </section>
    <section>
        <iframe data-src="../improved-sandbox/improved-boilerplate.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>An improved sandbox</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../improved-sandbox/imported-objects.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Sandbox with a horse!</li>
                </ul>
            </div>
        </div>
    </section>

    <section class="intro">
        <h2>Lighting</h2>
    </section>

    <script src="highlight.min.js"></script>
    <script src="slideshow.js"></script>
  </body>
</html>
