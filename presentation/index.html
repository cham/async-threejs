<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>A simple scene</title>
    <link href="http://fonts.googleapis.com/css?family=Roboto" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Reenie+Beanie" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="highlight.min.css">
    <style>
    html {
        height: 100%;
        font-family: sans-serif;
    }
    h2 {
        font-size: 2.5em;
        font-weight: normal;
        font-style: italic;
    }
    body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        height: 100%;
        font-size: 1.3em;
        font-family: Roboto, sans-serif;
    }
    iframe , section {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        border: 0;
        z-index: 0;
    }
    section {
        display: none;
    }
    ul {
        padding: 0;
        margin: 0;
    }
    ul li {
        list-style-type: none;
    }
    ul ol li {
        list-style-type: decimal;
    }
    .content {
        z-index: 1;
        position: absolute;
        top: 0;
        left: 0;
        background: #333;
        color: #fff;
        display: none;
    }
    .transitionable {
        transition: left 0.75s ease-in-out;
    }
    .subsection {
        padding: 12px;
        display: none;
    }
    .content .subsection:first-of-type {
        display: block;
    }
    .intro {
        background: #69f;
        font-family: 'Reenie Beanie', serif;
        height: 100%;
        text-align: center;
    }
    .intro h2 {
        position: relative;
        top: 50%;
        transform: translateY(-50%);
        color: #fff;
    }
    .intro h3 {
        position: relative;
        top: 50%;
        transform: translateY(-50%);
        color: #fff;
    }
    .always-invisible {
        visibility: hidden;
        padding: 0;
    }
    </style>
  </head>
  <body>

    <section class="intro">
        <h2>Learning Three.js</h2>
        <h3>Dan Neame <a href="https://twitter.com/cham">@cham</a></h3>
        <h3><a href="http://dan.nea.me">dan.nea.me</a></h3>
    </section>

    <section class="intro">
        <h2>What is Three.js?</h2>
    </section>
    <section>
        <iframe data-src="http://www.youtube.com/embed/YY7J6xIkt9M?autoplay=1&amp;autohide=1" width="100%" height="100%" wmode="transparent"></iframe>
    </section>
    <section>
        <iframe data-src="http://www.youtube.com/embed/ADRf8SE3RbM?autoplay=1&amp;autohide=1&amp;start=31" width="100%" height="100%" wmode="transparent"></iframe>
    </section>
    <section>
        <iframe data-src="http://www.youtube.com/embed/c69EwOhj-_Y?autoplay=1&amp;autohide=1" width="100%" height="100%" wmode="transparent"></iframe>
    </section>
    <section>
        <iframe data-src="http://www.youtube.com/embed/R0O_9bp3EKQ?autoplay=1&amp;autohide=1" width="100%" height="100%" wmode="transparent"></iframe>
    </section>
    <section>
        <iframe data-src="http://www.youtube.com/embed/GF2s5r-trRQ?autoplay=1&amp;autohide=1" width="100%" height="100%" wmode="transparent"></iframe>
    </section>

    <section class="intro">
        <h2>A simple scene</h2>
    </section>
    <section>
        <iframe data-src="../lights-camera-objects/a-simple-scene.html" width="100%" height="100%" wmode="transparent"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Scenes are containers for your three.js objects</li>
                    <li>You <i>can</i> have multiple scenes, but usually you only need one</li>
                </ul>
<pre><code class="js">
    var scene = new THREE.Scene(); // fill me with stuff!

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>We'll need a camera to take pictures of our scene</li>
                    <li>As with scenes, you'll often only need one of these</li>
                    <li>There are a few different types of camera, but PerspectiveCamera will give you a 'natural' look</li>
                    <li>It takes 4 arguments - the field of view, the view aspect, the 'near' cutoff and the 'far' cutoff</li>
                    <li>If you don't need to specify an argument, leave it out to use the default value</li>
                </ul>
<pre><code class="js">
    var wSize = windowSize();
    var camera = new THREE.PerspectiveCamera(40, wSize.width / wSize.height);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>The renderer renders the objects in our scene to the screen</li>
                    <li>There are 3 renderers - CSS, Canvas and WebGL</li>
                    <li>We'll only deal with the WebGL renderer for this talk</li>
                </ul>
<pre><code class="js">
    var renderer = new THREE.WebGLRenderer();

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Now that we have our scene, camera and renderer, we set the size of the renderer...</li>
                    <li>Execute a render, specifying the scene we want to render and the camera to render with...</li>
                    <li>and append the domElement of the renderer to the body of our HTML document</li>
                </ul>
<pre><code class="js">
    renderer.setSize(wSize.width, wSize.height);
    renderer.render(scene, camera);

    document.body.appendChild(renderer.domElement);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>The exciting result is an empty screen, as we've not added anything to our scene yet!</li>
                    <li>You can change the background colour of our render via renderer.setClearColor(hex);</li>
                </ul>
<pre><code class="js">
    renderer.setClearColor(0xff6699);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the code in it's entirety, it's running in the background right now</li>
                </ul>
<pre><code class="js">
    function windowSize(){
        return {
            width: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
            height: Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
        };
    }

    var wSize = windowSize();

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(40, wSize.width / wSize.height);
    var renderer = new THREE.WebGLRenderer();

    renderer.setClearColor(0xff6699);
    renderer.setSize(wSize.width, wSize.height);
    renderer.render(scene, camera);

    document.body.appendChild(renderer.domElement);

</code></pre>
        </div>
    </section>

    <section class="intro">
        <h2>A less simple scene</h2>
    </section>
    <section>
        <iframe data-src="../lights-camera-objects/a-less-simple-scene.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Our scene works but is a bit boring, there's nothing in it!</li>
                    <li>let's add a sphere to start</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Meshes in Three are composed of two things - Geometry and one or more Materials</li>
                    <li>Think of geometry as the shape and material as the paint</li>
                    <li>When these are combined, we have a Mesh that can be added to the scene</li>
                </ul>
<pre><code class="js">
    var mesh = new THREE.Mesh(geometry, material);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Spheres take 7 arguments, for a basic sphere you only need the first argument - the radius</li>
                    <li>The next two arguments define the number of horizontal and vertical segments</li>
                    <li><small>(the next four are used to make sphere segments, if you just want a part of a sphere)</small></li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.SphereGeometry(50, 16, 16);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>After we have defined our Geometry, it's time to paint it with a Material</li>
                    <li>MeshBasicMaterial defines a basic material</li>
                    <li>This material type does not require lighting, and simply paints it the colour we've specified</li>
                    <li>Materials take a bunch of options - I'm not going to cover them all, the docs are pretty comprehensive</li>
                </ul>
<pre><code class="js">
    var material = new THREE.MeshBasicMaterial({color: 0x00ff00});

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's our complete sphere() function</li>
                </ul>
<pre><code class="js">
    function sphere(){
        var geometry = new THREE.SphereGeometry(50, 16, 16);
        var material = new THREE.MeshBasicMaterial({color: 0x00ff00});

        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>To add it to the scene, we use scene.add</li>
                </ul>
<pre><code class="js">
    scene.add(sphere());

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>And we'll need to move the camera out a bit, so it's not inside the sphere</li>
                </ul>
<pre><code class="js">
    camera.position.set(0, 0, 300);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>It looks like a circle since the basic material does not show any shading</li>
                    <li>If we turn on wireframes then it's a bit clearer what's going on</li>
                    <li><small>Some live coding here! Or edit a-less-simple-scene.html to the following:</small></li>
                </ul>
<pre><code class="js">
    function sphere(){
        var geometry = new THREE.SphereGeometry(50, 16, 16);
        var material = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true
        });

        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the code for our less simple scene</b></li>
                </ul>
<pre><code class="js">
    function sphere(){
        var geometry = new THREE.SphereGeometry(50, 16, 16);
        var material = new THREE.MeshBasicMaterial({color: 0x00ff00});

        return new THREE.Mesh(geometry, material);
    }

    var wSize = windowSize();

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(40, wSize.width / wSize.height);
    var renderer = new THREE.WebGLRenderer();

    scene.add(sphere());

    camera.position.set(0, 0, 300);

    renderer.setClearColor(0xffffff);
    renderer.setSize(wSize.width, wSize.height);
    renderer.render(scene, camera);

    document.body.appendChild(renderer.domElement);

</code></pre>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>A lit scene</h2>
    </section>
    <section>
        <iframe data-src="../lights-camera-objects/a-lit-scene.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>If we want anything other than basic materials then we're going to need some lights</li>
                    <li>There are a bunch of different lights in Three that all work in different ways</li>
                    <li>In this example we'll use a SpotLight</li>
                </ul>
<pre><code class="js">
    var light = new THREE.SpotLight();

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Spotlights have a <b>position</b> and shine a cone of light on a <b>target</b></li>
                    <li>The target will be 0, 0, 0 by default, but I've included it for reference</li>
                </ul>
<pre><code class="js">
    light.position.set(1000, 1000, 1000);
    light.target.set(0, 0, 0);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>SpotLights take up to 5 arguments:</b></li>
                    <li>Their colour</li>
                    <li>Their intensity</li>
                    <li>The distance they illuminate to (default 0 = infinity)</li>
                    <li>The angle of the light cone</li>
                    <li>The falloff rate, if distance is not 0</li>
                </ul>
<pre><code class="js">
    var light = new THREE.SpotLight(0xff0000, 0.8, 500, 90, 2);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>I've changed the material the sphere uses to a Lambert material, so that the light affects it</li>
                    <li>I'll cover materials in more detail later</b></li>
                </ul>
<pre><code class="js">
    function sphere(){
        var geometry = new THREE.SphereGeometry(50, 16, 16);
        var material = new THREE.MeshLambertMaterial({color: 0x00ff00});

        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the code for our lit scene</b></li>
                </ul>
<pre><code class="js">
    function sphere(){
        var geometry = new THREE.SphereGeometry(50, 16, 16);
        var material = new THREE.MeshLambertMaterial({color: 0x00ff00});

        return new THREE.Mesh(geometry, material);
    }

    var wSize = windowSize();

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(40, wSize.width / wSize.height);
    var renderer = new THREE.WebGLRenderer();
    var light = new THREE.SpotLight();

    scene.add(sphere());
    scene.add(light);

    camera.position.set(0, 0, 300);
    light.position.set(1000, 1000, 1000);

    renderer.setClearColor(0xffffff);
    renderer.setSize(wSize.width, wSize.height);
    renderer.render(scene, camera);

    document.body.appendChild(renderer.domElement);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Object Positions</h2>
    </section>
    <section>
        <iframe data-src="../lights-camera-objects/multiple-spheres.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>It's straightforward to add multiple spheres to our scene</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>I've added a new function called "randomlyPositionedSphere"</li>
                    <li>This function calls sphere() as with our last example, but also sets the position of our sphere</li>
                    <li>The position is random within the range specified with maxPosition, in all three axes</li>
                </ul>
<pre><code class="js">
    function randomlyPositionedSphere(maxPosition){
        var mesh = sphere();

        mesh.position.set(
            (Math.random() * maxPosition) - (maxPosition / 2),
            (Math.random() * maxPosition) - (maxPosition / 2),
            (Math.random() * maxPosition) - (maxPosition / 2)
        );

        return mesh;
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Then we call randomlyPositionedSphere 100 times with a for loop</li>
                </ul>
<pre><code class="js">
    for(var i = 0; i < 100; i++){
        scene.add(randomlyPositionedSphere(boxSize));
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Refreshing the page gives us a random scene each time</li>
                </ul>
            </div>
        </div>
    </section>

    <section class="intro">
        <h2>Animation</h2>
    </section>
    <section>
        <iframe data-src="../animation-basics/circular-motion.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Time for some maths!</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>To plot the path of a circle, we can use a sine and cosine wave:</li>
                    <li>A sine wave for one axis, and a cosine wave for the other</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
            <div class="subsection">
                <ul>
                    <li>If both axes use a sine wave, or both use a cosine wave, then we get a nicely eased but linear line, diagonally</li>
                    <li><small>some live coding! or change all instances of "Math.cos" to "Math.sin" in animation-basics/circular-motion.html</small></li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../animation-basics/moving-camera.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Let's look at how we can use this to give our camera a circular path</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Up to now, we've only rendered the scene once</li>
                    <li>If we're going to have animation in the scene, we'll need to render each time something changes</li>
                    <li>requestAnimationFrame will allow us to render our scene up to 60 times per second</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>We create a tick function, that:</li>
                    <li>
                        <ol>
                            <li>positions the camera</li>
                            <li>renders the scene</li>
                            <li>increments a tick counter</li>
                            <li>schedules another call to itself with requestAnimationFrame</li>
                        </ol>
                    </li>
                </ul>
<pre><code class="js">
    function tick(){
        camera.position.set(cameraX, 0, cameraZ);

        renderer.render(scene, camera);

        tickCount += 0.01;
        requestAnimationFrame(tick);
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>In order to move the camera in a circular orbit, we set the x coordinate to a position on a sine wave, and the z coordinate to a position on a cosine wave</li>
                    <li>renderer.render(scene, camera) is replaced with the following code:</li>
                </ul>
<pre><code class="js">
    var tickCount = 0;
    function tick(){
        var cameraX = boxSize * Math.cos(tickCount);
        var cameraZ = boxSize * Math.sin(tickCount);

        camera.position.set(cameraX, 0, cameraZ);
        camera.lookAt(new THREE.Vector3(0,0,0));

        renderer.render(scene, camera);

        tickCount += 0.01;
        requestAnimationFrame(tick);
    }
    tick();

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>It's necessary to tell the camera where to look after we've moved it</li>
                    <li>Without camera.lookAt, it will keep facing in the same direction when moved rather than tracking 0, 0, 0</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../animation-basics/more-complicated-paths.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>A bit more maths!</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>This is the same example as before, but I've increased the period of the x co-ordinate</li>
                    <li>x is now Math.cos(time*3) instead of Math.cos(time)</li>
                    <li>This means that we'll be drawing 3 circles per iteration in x, and 1 in y</li>
                    <li>The result of this is a helix type path</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../animation-basics/moving-camera-2.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Here's the same path applied to the camera position in our sphere scene</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The only change is the following line in tick():</li>
                </ul>
<pre><code class="js">
        var cameraX = boxSize * Math.cos(tickCount*3);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>You can come up with some really interesting paths just by modifying the period of the sine and cosine waves</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../animation-basics/moving-camera-moving-objects.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Why not have each sphere follow a sine wave?</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>sphere() now gives the geometry a random size to make things a bit more interesting</li>
                </ul>
<pre><code class="js">
   function sphere(){
        var geometry = new THREE.SphereGeometry(Math.random() * 50, 16, 16);
        var material = new THREE.MeshLambertMaterial({color: 0x00ff00});

        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>randomlyPositionedSphere assigns a random "speed" Vector to each mesh</li>
                    <li>Vector3 is a simple object that represents a three dimensional Vector</li>
                    <li>You can use them for anything, but representing x, y and z is the most common case</li>
                </ul>
<pre><code class="js">
    function randomlyPositionedSphere(maxPosition){
        var mesh = sphere();

        mesh.position.set(
            (Math.random() * maxPosition) - (maxPosition / 2),
            (Math.random() * maxPosition) - (maxPosition / 2),
            (Math.random() * maxPosition) - (maxPosition / 2)
        );

        mesh.speed = new THREE.Vector3(
            Math.random() * 10 - 5,
            Math.random() * 10 - 5,
            Math.random() * 10 - 5
        );


        return mesh;
    }

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>And on each tick(), we call moveSphere for each sphere in the scene:</li>
                </ul>
<pre><code class="js">
    function moveSphere(mesh, count){
        mesh.position.x += Math.sin(count) * mesh.speed.x;
        mesh.position.y += Math.sin(count) * mesh.speed.y;
        mesh.position.z += Math.sin(count) * mesh.speed.z;
    }

    ...

    function tick(){
        for(var i = 0; i < 100; i++){
            moveSphere(spheres[i], tickCount);
        }
        ...
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Geometries</h2>
    </section>
    <section>
        <iframe data-src="../objects/planes.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Planes</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Planes are one of the simplest geometries</li>
                    <li>Composed of four vertices and two faces</li>
                    <li>They have a width and height but no depth</li>
                    <li>Flat objects like this are known as 'Shapes'</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Their constructor takes width as the first argument and height as the second</li>
                    <li>The third and fourth (optional) arguments define how many width and height segments they should have respectively</li>
                </ul>
<pre><code class="js">
        var geometry = new THREE.PlaneGeometry(40, 60);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/vertices.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Vertices</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>A vertex is a point in 3d space</li>
                    <li>Geometries are composed of multiple vertices</li>
                    <li>The wireframe of an object is defined by the edges between these vertices</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Our plane has 4 vertices, which are highlighted in the example like so:</li>
                </ul>
<pre><code class="js">
    var object = plane();

    object.geometry.vertices.forEach(function(vertex){
        scene.add(positionedSphere(vertex.x, vertex.y, vertex.z));
    });

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/faces.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Faces</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>A face is an individual surface of a solid object</li>
                    <li>Faces are always flat, and usually triangles (THREE.Face3), though you can create custom geometry with square faces (THREE.Face4)</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Faces are defined by the vertices that they join together</li>
                    <li>In our face() function, we:
                        <ol>
                            <li>create a new Geometry and a basic blue Material</li>
                            <li>set the vertices of the Geometry to those passed to the function</li>
                            <li>define a single face composed of the 0th, 1st and 2nd vertex</li>
                            <li>return the Mesh</li>
                        </ol>
                    </li>
                    <li>This gives us the single blue face we see in the example</li>
                </ul>
<pre><code class="js">
    function face(vertices){
      var geometry = new THREE.Geometry();
      var material = new THREE.MeshBasicMaterial({ color: 0x0000ff });

      geometry.vertices = vertices;
      geometry.faces.push(new THREE.Face3(0, 1, 2));

      return new THREE.Mesh(geometry, material);
    }

    var object = plane();

    scene.add(
        face(object.geometry.vertices.slice(0, 3))
    );

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/boxes.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Boxes (formerly "Cubes")</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Boxes have a similar constructor to planes, but with an extra dimension for depth</li>
                    <li>As with planes, you can supply an additional arguments if you want more segments in each dimension</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.BoxGeometry(40, 50, 60);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/circles.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Circles</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Circles are circular Shapes, made out of multiple Face3s</li>
                    <li>The default number of segments is 8, but you'll probably want to up this in nearly all instances</li>
                    <li>The example here is using 16 segments instead, so it has 17 vertices and 16 faces</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The first argument passed to CircleGeometry is the radius</li>
                    <li>The second argument passed to CircleGeometry is the segment count</li>
                    <li>The third and fourth arguments (both optional) allow you to define circle sections</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.CircleGeometry(40, 16);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/spheres.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Spheres</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Spheres are three dimensional circular geometries</li>
                    <li>Each vertex is at the same distance from the center point</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Spheres in Three.js are UV Spheres</li>
                    <li>This means they are generated with a sequence of rings and segments, like a plane wrapped around a central point</li>
                    <li>You can also make Spheres using icosa-, tetra-, octa- and dodeca-hedrons</li>
                    <li>UV Spheres are easiest to map textures onto due to their correlation with planes</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>As we covered earlier, SphereGeometries take 7 arguments</li>
                    <li>For a basic sphere you only need the first argument - the radius</li>
                    <li>The next two arguments define the number of horizontal and vertical segments</li>
                    <li>The next four are used to make partial spheres</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.SphereGeometry(40, 16, 12);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/rings.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Rings</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Rings are shapes defined by two circles</li>
                    <li>An outer circle, and an inner circle that defines a hole in the middle</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The RingGeometry constructor takes 6 arguments</li>
                    <li>The first two are the radii of the outer and inner circle</li>
                    <li>The third and fourth define the number of segments</li>
                    <li>The fifth and six allow you to define partial rings</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.RingGeometry(30, 24, 16, 2);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/tori.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Tori</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Spheres are to circles as tori are to rings</li>
                    <li>Instead of defining an outer and inner radius, you define the radius of the torus, and the radius of the tube</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The TorusGeometry constructor takes 5 arguments</li>
                    <li>Interestingly, this is one less than the RingGeometry</li>
                    <li>The first argument is the radius of the torus</li>
                    <li>The second argument is the radius of the tube</li>
                    <li>The third defines the number of radial segments</li>
                    <li>The fourth defines the number of tubular segments</li>
                    <li>The fifth argument allows you to draw partial tori</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.TorusGeometry(30, 6, 8, 16);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/torusknots.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Torus Knots</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Torus Knots are pretty fun geometries that generate some interesting shapes</li>
                    <li>They are defined in a similar way to tori, in that they have a radius and a tubular radius</li>
                    <li>The twisting shape is defined by two numbers, p and q</li>
                    <li>For a torus knot to be complete, both p and q must be integers</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The constructor of a TorusKnotGeometry takes 7 arguments</li>
                    <li>
                        <ol>
                            <li>The radius</li>
                            <li>The tubular radius</li>
                            <li>The number of radial segments</li>
                            <li>The number of tubular segments</li>
                            <li>p</li>
                            <li>q</li>
                            <li>The height scale - how much the torusknot deviates in the z axis</li>
                        </ol>
                    </li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.TorusKnotGeometry(30, 6, 64, 16);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/cylinders.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Cylinders</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Cylinders are circles extruded in the y axis</li>
                    <li>You can supply a different radius to the top and bottom of the cylinder</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>CylinderGeometry takes 6 arguments:</li>
                    <li>
                        <ol>
                            <li>The radius at the top of the cylinder</li>
                            <li>The radius at the bottom of the cylinder</li>
                            <li>The height of the cylinder</li>
                            <li>The number of radial segments</li>
                            <li>The number of height segments</li>
                            <li>A boolean denoting whether or not the cylinder is open (true) or capped (false)</li>
                        </ol>
                    </li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.CylinderGeometry(20, 20, 60);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/cones.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Cones</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>If you define one of the radii for a Cylinder as 0 then the result is a cone</li>
                    <li>Here's the same Cylinder we saw in the previous example, with a top radius of 0:</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.CylinderGeometry(0, 20, 60);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/pyramids.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Pyramids</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>A cone with three sides is a pyramid</li>
                    <li>Here's the same Cylinder we saw in the previous example, but with 3 radial segments:</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.CylinderGeometry(0, 20, 60, 3);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/all-hedrons.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Tetra-, icosa-, octa- and dodecahedrons</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>All define die-like shapes</li>
                    <li>As you increase the number of segments they become more like spheres</li>
                    <li>Better than UV Spheres if you need to alter their geometries</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>All of these geometries take 2 arguments:</li>
                    <li>
                        <ol>
                            <li>The radius of the geometry</li>
                            <li>The detail of the geometry (default 0)</li>
                        </ol>
                    </li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.TetrahedronGeometry(16);
    var geometry = new THREE.IcosahedronGeometry(16);
    var geometry = new THREE.OctahedronGeometry(16);
    var geometry = new THREE.DodecahedronGeometry(16);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../objects/detailed-hedrons.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Detailed tetra-, icosa-, octa- and dodecahedrons</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here are some examples with their subdivisions turned up to 2:</li>
                    <li>Even with the smallest increase in vertices they begin to appear more like spheres</li>
                </ul>
<pre><code class="js">
    var geometry = new THREE.TetrahedronGeometry(16, 2);
    var geometry = new THREE.IcosahedronGeometry(16, 2);
    var geometry = new THREE.OctahedronGeometry(16, 2);
    var geometry = new THREE.DodecahedronGeometry(16, 2);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Materials</h2>
    </section>
    <section>
        <iframe data-src="../materials/sphere-lambert-basic-phong.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Material types</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>
                        The three most commonly used material types are:
                        <ol>
                            <li>Basic</li>
                            <li>Lambert</li>
                            <li>Phong</li>
                        </ol>
                    </li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li><b>MeshBasicMaterial</b></li>
                    <li>&nbsp;</li>
                    <li>The green sphere in this demo uses a MeshBasicMaterial</li>
                    <li>Basic materials are just that: pretty basic</li>
                    <li>They're good for scenes that don't require lighting, or where you need a uniform, flat colour</li>
                    <li>They can be great for visualisations where you want a flat style, or where you want an exact colour</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>MeshBasicMaterials usually have a colour</li>
                    <li>They can also have a texture, light, specular, alpha or environment map (more on these later)</li>
                    <li>Or you can show them as wireframes - like in the previous section on objects</li>
                    <li>In this example we've just given our sphere a flat green colour:</li>
                </ul>
<pre><code class="js">
    function basicSphere(){
        var geometry = new THREE.SphereGeometry(15, 64, 64);
        var material = new THREE.MeshBasicMaterial({color: 0x33ff66});

        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
            <div class="subsection">
                <ul>
                    <li><b>MeshLambertMaterial</b></li>
                    <li>&nbsp;</li>
                    <li>The brown sphere in this demo uses a MeshLambertMaterial</li>
                    <li>Unlike Basic materials, Lambert shaded materials take lighting into effect</li>
                    <li>They are good for creating dull, non-shiny objects like clay</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>MeshLambertMaterials take all the same parameters as MeshBasicMaterials</li>
                    <li>But since they are effected by lighting, they give a more realistic effect</li>
                </ul>
<pre><code class="js">
    function lambertSphere(){
        var geometry = new THREE.SphereGeometry(15, 64, 64);
        var material = new THREE.MeshLambertMaterial({color: 0xff6633});

        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
            <div class="subsection">
                <ul>
                    <li><b>MeshPhongMaterial</b></li>
                    <li>&nbsp;</li>
                    <li>The blue sphere in this demo uses a MeshPhongMaterial</li>
                    <li>These are very similar to Lambert materials, but have a shinier shading</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>MeshPhongMaterials, like Lambert, take all the same parameters as MeshBasicMaterials</li>
                    <li>They also have a 'shininess' parameter, which I've increased in this example (the default is 50)</li>
                </ul>
<pre><code class="js">
    function phongSphere(){
        var geometry = new THREE.SphereGeometry(15, 64, 64);
        var material = new THREE.MeshPhongMaterial({
            color: 0x3366ff,
            shininess: 90
        });
        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-shading.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Shading types</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>You can control the shading type for any material affected by lighting</li>
                    <li>This affects how the lighting is smoothed over each face</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>
                        In this example we have 3 Icosahedrons with the 3 different shading types:
                        <ol>
                            <li>Smooth shading, in blue (the default shading)</li>
                            <li>Flat shading, in green</li>
                            <li>No shading, in red</li>
                        </ol>
                    </li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Flat shading is much faster than smooth shading<li>
                    <li>As you can see, there's pretty much no discernable difference between Flat and No shading</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Phong shaded sphere</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Colouring in a sphere is pretty cool, but there's a lot more we can do with materials</li>
                    <li>You can make some pretty spectacular scenes with a simple object or two and good use of materials</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Let's make a realistic looking globe with just a few spheres</li>
                    <li>First off, we'll take a sphere and colour it blue</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>I've turned the shininess down on this sphere</li>
                    <li>This makes it look a bit more like a "sea" than the previous Phong sphere</li>
                </ul>
<pre><code class="js">
    function sphere(){
        var geometry = new THREE.SphereGeometry(40, 64, 64);
        var material = new THREE.MeshPhongMaterial({
            color: 0x3366ff,
            shininess: 50
        });

        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-texturemap.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Texture maps</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Texture maps are <i>great</i> for bringing a bit of life to your objects</li>
                    <li>They wrap a bitmap around your object</li>
                    <li>This is straightforward for UV spheres - SphereGeometries use this mapping</li>
                    <li>For an Icosahedron, you'd need a different map, based on triangles rather than a rectangle</li>
                    <li>For this reason, when you're working with textures and spheres, a SphereGeometry is usually easiest</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>In this example, we have the blue, phong-shaded sphere from our previous example on the right</li>
                    <li>And the same sphere with our texture map applied on the left</li>
                    <li>I've included a Plane in the background with the same texture applied to it</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The earth map is straight from Google images</li>
                    <li>This is what makes UV spheres so much easier to work with than Icosahedrons</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>If you want to distort the shape of your sphere, Icosahedrons are better</li>
                    <li>UV Spheres lead to 'tearing' since not all of their vertices are joined by a face</li>
                    <li>In Icosahedrons, no vertices form an edge, which you get at the top or bottom of UV spheres</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the code for our textured sphere</li>
                    <li>THREE.ImageUtils.loadTexture handles the loading of the texture for us, so it's pretty straightforward</li>
                    <li>Notice I've dropped the colour - it's not needed any more</li>
                </ul>
<pre><code class="js">
    function texturedSphere(){
        var textureMap = 'textures/earthmap.jpg';
        var geometry = new THREE.SphereGeometry(30, 64, 64);
        var material = new THREE.MeshPhongMaterial({
            map: THREE.ImageUtils.loadTexture(textureMap),
            shininess: 50
        });
        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-bumpmap.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Bump maps</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Bump maps are greyscale bitmaps, which can be used to simulate bumps and wrinkles on an object</li>
                    <li>They work by altering the surface of the object during lighting calculations</li>
                    <li>The <i>geometry</i> of the object is not changed - this is done by the shader</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>In this example, I've applied the same bump map to the blue sphere and to the textured sphere</li>
                    <li>You should be able to see the bumps on each</li>
                    <li>The bump map is shown behind, as a texture on the plane - the lighter the pixel, the higher the bump</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the texture and bump map applied to our sphere</li>
                    <li>Notice the bumpScale property - increasing this will increase the bump size on the sphere</li>
                </ul>
<pre><code class="js">
    function bumpSphere(){
        var textureMap = 'textures/earthmap.jpg';
        var bumpMap = 'textures/bumpmap.jpg';
        var geometry = new THREE.SphereGeometry(30, 64, 64);
        var material = new THREE.MeshPhongMaterial({
            map: THREE.ImageUtils.loadTexture(textureMap),
            shininess: 50,
            bumpMap: THREE.ImageUtils.loadTexture(bumpMap),
            bumpScale: 0.3
        });
        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-specularmap.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Specular maps</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Specular maps control how shiny each part of the object should be</li>
                    <li>Like bump maps, these are just greyscale bitmaps</li>
                    <li>The whiter the pixel, the shinier that part of the object will be</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>I've applied the specular map to our blue sphere and added it to our textured, bumped sphere</li>
                    <li>As before, it's viewable as a texture on the plane</li>
                    <li>This allows us to make only the sea shiny - the land isn't shiny at all</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the texture, bump and specular map applied to our sphere</li>
                </ul>
<pre><code class="js">
    function specularSphere(){
        var textureMap = 'textures/earthmap.jpg';
        var bumpMap = 'textures/bumpmap.jpg';
        var specularMap = 'textures/specularmap.jpg';
        var geometry = new THREE.SphereGeometry(30, 64, 64);
        var material = new THREE.MeshPhongMaterial({
            map: THREE.ImageUtils.loadTexture(textureMap),
            bumpMap: THREE.ImageUtils.loadTexture(bumpMap),
            bumpScale: 0.3,
            specularMap: THREE.ImageUtils.loadTexture(specularMap),
            shininess: 50
        });
        return new THREE.Mesh(geometry, material);
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-alphamap.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Alpha maps</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>So far we've done everything with just one sphere and one material</li>
                    <li>If we want to add clouds to our globe, they'll need to be on a separate sphere</li>
                    <li>What I've added here is an extra sphere, very slightly larger than our globe sphere, which rotates at a different speed</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>The new, larger sphere has an alpha map applied</li>
                    <li>As you may have guessed, an alpha map controls the transparency of a material</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>You can also see the alpha map applied to a lone sphere by itself, next to our globe</li>
                    <li>Since clouds are white, we don't need to specify anything other than the alpha map</li>
                    <li>Where the alpha map is white, the object will be visible, and show it's default colour, which handily is white</li>
                    <li>We could quite easily make the clouds red by applying a colour property to our cloud sphere</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Here's the code for our cloud sphere, whose radius is 0.1 units bigger than our globe sphere</li>
                    <li>The 'transparent' property is required in order to enable the alpha map</li>
                    <li>Notice the tick() method in our clouds function - this keeps the clouds spinning</li>
                </ul>
<pre><code class="js">
    function clouds(){
        var textureMap = 'textures/cloudmap.jpg';
        var geometry = new THREE.SphereGeometry(30.1, 64, 64);
        var material = new THREE.MeshPhongMaterial({
            alphaMap: THREE.ImageUtils.loadTexture(textureMap),
            transparent: true
        });
        var mesh = new THREE.Mesh(geometry, material);

        function tick(){
            requestAnimationFrame(tick);
            mesh.rotation.y += 0.0005;
        }
        tick();

        return mesh;
    }

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-transparency.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Transparency</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-materialsides.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Material sides</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../materials/sphere-customshader.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Custom shaders</li>
                </ul>
            </div>
        </div>
    </section>

    <section class="intro">
        <h2>Importing Meshes</h2>
    </section>
    <section>
        <iframe data-src="../importing-objects/importing-objects.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Importing objects</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../importing-objects/importing-objects-textured.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Using imported textures</li>
                </ul>
            </div>
        </div>
    </section>

    <section class="intro">
        <h2>Improved Sandboxes and Dev Tools</h2>
    </section>
    <section>
        <iframe data-src="../improved-sandbox/improved-boilerplate.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>An improved sandbox</li>
                </ul>
            </div>
        </div>
    </section>
    <section>
        <iframe data-src="../improved-sandbox/imported-objects.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Sandbox with a horse!</li>
                </ul>
            </div>
        </div>
    </section>

    <section class="intro">
        <h2>Lighting</h2>
    </section>
    <section>
        <iframe data-src="../lighting/shadows.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Shadows</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Spotlights are probably the type of light you will use the most</li>
                    <li>As we saw earlier, Spotlights have a position and shine a cone of light on a target</li>
                </ul>
<pre><code class="js">
    light.position.set(1000, 1000, 1000);
    light.target.set(0, 0, 0);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>It is also possible for a Spotlight (or any directional light) to cast shadows</li>
                    <li>To enable shadows, enable the 'castShadow' property on the light</li>
                </ul>
<pre><code class="js">
    light.castShadow = true;

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Each mesh in your scene will also need to be told to cast a shadow, and to receive a shadow</li>
                    <li>These are both off by default</li>
                </ul>
<pre><code class="js">
    mesh.castShadow = true;
    mesh.receiveShadow = true;

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>If your shadow doesn't look very crisp, update the shadowmap resolution</li>
                    <li>This is controlled by the shadowMapWidth and shadowMapHeight properties</li>
                    <li>These values must be a power of 2!</li>
                </ul>
<pre><code class="js">
    light.shadowMapWidth = 1024;
    light.shadowMapHeight = 1024;

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>The darkness of your shadow can be controlled with the "shadowDarkess" property</li>
                </ul>
<pre><code class="js">
    light.shadowDarkness = 0.4;

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>Finally, you can enable the "camera frustrum" on the light</li>
                    <li>This allows you to see the boundaries of the light cone</li>
                    <li>Useful for debugging!</li>
                </ul>
<pre><code class="js">
    light.shadowCameraVisible = true;

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>So, here's everything you need for a decent shadow:</li>
                </ul>
<pre><code class="js">
    light.castShadow = true;
    light.shadowMapWidth = 1024;
    light.shadowMapHeight = 1024;
    light.shadowDarkness = 0.4;

    ...

    mesh.castShadow = true;
    mesh.receiveShadow = true;

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
    </section>
    <section>
        <iframe data-src="../lighting/directional.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Directional Lights</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Directional lights are similar to SpotLights, but without a light cone</li>
                    <li>Light is mapped as a plane moving from the light position to the target position</li>
                    <li>Apart from this difference, Directional lights have almost all the same properties as SpotLights</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>DirectionalLights only take 2 arguments - the colour and intensity</b></li>
                </ul>
<pre><code class="js">
    var light = new THREE.DirectionalLight(colour, intensity);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../lighting/ambient.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Ambient Lights</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Ambient lights apply their colour to all surfaces of objects in the scene equally</li>
                    <li>They take only 1 argument - the colour</li>
                </ul>
<pre><code class="js">
    var light = new THREE.AmbientLight(colour);

</code></pre>
            </div>
            <div class="subsection">
                <ul>
                    <li>I've removed the plane / floor in this example</li>
                    <li>Otherwise, you wouldn't be able to see the objects!</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>AmbientLights are best used to lighten your scene globally very slightly</li>
                    <li>If the colour is too intense they will overpower all your other lights</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../lighting/hemispherelight.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Hemisphere Lights</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Hemisphere lights are similar to Directional lights, except their light is mapped as a hemisphere rather than a plane</li>
                    <li>This gives a softer, more "sun-like" effect</li>
                    <li>Hemisphere lights can also have a ground colour</li>
                    <li>This gives an uplight effect in the opposite direction to the main light</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../lighting/point.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Point Lights</li>
                </ul>
            </div>
            <div class="subsection">
                <ul>
                    <li>Point lights are a bit like light bulbs</li>
                    <li>They have a position, but no target, and shine in all directions</li>
                    <li>The distance property controls how far they shine</li>
                    <li>Quite fun to use on particles!</li>
                </ul>
<pre><code class="js">
    var light = new THREE.PointLight(colour, intensity, distance);

</code></pre>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Combining Lights</h2>
    </section>
    <section>
        <iframe data-src="../combined-lighting/sunlight.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Sunlight</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>
    <section>
        <iframe data-src="../combined-lighting/threepoint.html" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Three Point lighting</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Animating Geometries</h2>
    </section>
    <section>
        <iframe data-src="http://dan.nea.me/audioterrain" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Animating Geometries</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Reflection</h2>
    </section>
    <section>
        <iframe data-src="http://dan.nea.me/reflection" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Reflection</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Particles</h2>
    </section>
    <section>
        <iframe data-src="http://dan.nea.me/particlebox" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Particles</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Voxels</h2>
    </section>
    <section>
        <iframe data-src="http://dan.nea.me/voxel-castle" width="100%" height="100%"></iframe>
        <div class="content">
            <div class="subsection">
                <ul>
                    <li>Voxels</li>
                </ul>
            </div>
            <div class="subsection always-invisible"></div>
        </div>
    </section>

    <section class="intro">
        <h2>Fin</h2>
        <h3>Dan Neame <a href="https://twitter.com/cham">@cham</a></h3>
        <h3><a href="http://dan.nea.me">dan.nea.me</a></h3>
    </section>


    <script src="highlight.min.js"></script>
    <script src="slideshow.js"></script>
  </body>
</html>
